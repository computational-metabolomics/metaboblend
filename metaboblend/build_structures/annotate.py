#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright Â© 2019-2020 Jack Gisby, Ralf Weber
#
# This file is part of MetaboBlend.
#
# MetaboBlend is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MetaboBlend is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MetaboBlend.  If not, see <https://www.gnu.org/licenses/>.
#

import os
from typing import Sequence, Dict, Union

from metaboblend.parse import parse_ms_data
from metaboblend.databases.results import ResultsDb
from metaboblend.databases.substructures import SubstructureDb
from metaboblend.build_structures.build import build, gen_subs_table, get_possible_fragment_ions


def annotate_msn(msn_data: Union[str, os.PathLike, Dict[str, Dict[str, Union[int, list]]]],
                 path_substructure_db: Union[str, bytes, os.PathLike] = os.path.realpath(os.getcwd()),
                 path_out: Union[str, bytes, os.PathLike] = "",
                 ppm: int = 5,
                 ha_min: Union[int, None] = None,
                 ha_max: Union[int, None] = None,
                 max_atoms_available: int = 2,
                 max_degree: int = 4,
                 max_n_substructures: int = 3,
                 max_bde: Union[float, None] = 2000,
                 path_connectivity_db: Union[str, bytes, os.PathLike, None] = None,
                 ncpus: Union[int, None] = None,
                 minimum_frequency: Union[int, None] = None,
                 hydrogenation_allowance: int = 2,
                 yield_smis: bool = True,
                 isomeric_smiles: bool = False,
                 write_csv_output: bool = True,
                 retain_substructures: bool = False,
                 abs_error_peak: float = 0.001,
                 abs_error_precursor: float = 0.0005,
                 ) -> Dict[str, Sequence[Dict[str, int]]]:
    """
    Generate molecules of a given mass using chemical substructures, connectivity graphs and spectral trees or
    fragmentation spectra. Final structures and rankings are yielded by the function as a dictionary and/or written in
    text format. For the generation of structures without MSn data, see
    :py:meth:`metaboblend.build_structures.generate_structures`.

    :param msn_data: Either a dictionary or the path to an MSP file. MSP files are parsed by
        :py:meth:`metaboblend.parse.parse_ms_data` before being converted into a dictionary. If a dictionary is
        provided, it must contain one item per fragmentation spectrum; the keys of the dictionary should be a unique ID
        for the query and the corresponding value must itself be a dictionary, containing the following:

        - "exact_mass": `float` (neutral mass of query) OR "precursor_mz": `float` (mz of precursor ion)
        - "mf": `[C, H, N, O, P, S]` (a list of 6 integers)
        - "neutral_fragment_masses": `[float, float, ...]` (list of neutral fragment masses) OR "fragment_mzs":
            `[float, float, ...]` (list of fragment mzs)
        - "precursor_type": `str` (e.g. "[M+H]+", required for calculating neutral masses from ion mzs)

        The dictionary or MSP path is fed to :py:meth:`metaboblend.parse.parse_ms_data`.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param path_out: Folder to which the SQLite 3 results database and CSV outputs should be written.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param ha_min: The minimum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param ha_max: The maximum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param max_atoms_available: The maximum number of  atoms available of each substructure to be considered for
        building molecules. `atoms_available` refers to the number of atoms on a substructure involved in forming
        chemical bonds (e.g. single or double bonds). `atoms_available` are also limited by the extensivity of the
        supplied connectivity database.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single,
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have
        a total degree of 3.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. The max number
        of substructures is also limited by the extensivity of the supplied connectivity database.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`. If the path is None, the default connectivity
        database bundled with MetaboBlend will be used.

    :param ncpus: How many CPUs to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique. Defaults to None, in which case this filtering method is not applied.

    :param hydrogenation_allowance: In order to represent re-arrangement events (the movement of hydrogens), in
        addition to attempting to build from substructures in prescribed_masses, we also attempt to build from
        `fragment_masses +- hydrogenation_allowance`. E.g. if `prescribed_masses = [141.5938]` and
        `hydrogenation_allowance = 1` then, to find candidate fragment substructures, we use as query the masses
        `[141.5938 - 1.007825, 141.5938, 141.5938 + 1.007825]`.

    :param yield_smis: If True, for each input molecule the function yields SMILEs the number of `fragment_masses` by
        which the structure was generated. Else, returns None.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :param write_csv_output: Whether to extract results from the SQLite3 database for deposition in CSV files.

    :param retain_substructures: Whether to record the substructures used to generate final structures.

    :param abs_error_peak: Allowable absolute mz deviation from MSn peaks.

    :param abs_error_precursor: Allowable absolute mz deviation of final structure from precursor mass.

    :return: For each input molecule yields a dictionary whose keys are SMILEs strings for the generated
        structures and values are the number of `fragment_masses` by which the structure was built (unless
        `yield_smi_dict = False`).
    """

    if ppm is None:
        ppm = 0

    if path_connectivity_db is None:
        path_connectivity_db = os.path.join(os.path.realpath(os.path.dirname(__file__)), "../data",
                                            "connectivity.sqlite")

    db = SubstructureDb(path_substructure_db, path_connectivity_db)
    results_db = ResultsDb(path_out, retain_substructures=retain_substructures)
    results_db.create_results_db()

    # prepare temporary table here - will only be generated once in case of multiple input
    table_name = gen_subs_table(
        db=db,
        ha_min=ha_min,
        ha_max=ha_max,
        max_degree=max_degree,
        max_atoms_available=max_atoms_available,
        minimum_frequency=minimum_frequency,
        max_mass=None
    )

    for i, ms in enumerate(parse_ms_data(msn_data)):

        if ms is None:
            continue

        results_db.add_ms(msn_data, ms["ms_id"], i, [ppm, ha_min, ha_max, max_atoms_available, max_degree,
                                                     max_n_substructures, hydrogenation_allowance, isomeric_smiles])

        for j, fragment_mass in enumerate(ms["neutral_fragment_masses"]):

            # start off by getting the substructures that could represent the fragment ion
            possible_fragment_ions = get_possible_fragment_ions(fragment_mass, db, hydrogenation_allowance, ppm,
                                                                abs_error_peak, table_name)

            smi_dict = build(
                db=db,
                mf=ms["mf"],
                exact_mass=ms["exact_mass"],
                max_n_substructures=max_n_substructures,
                prescribed_substructures=possible_fragment_ions,
                ppm=ppm,
                table_name=table_name,
                ncpus=ncpus,
                isomeric_smiles=isomeric_smiles,
                tolerance=abs_error_precursor,
                max_bde=max_bde
            )

            results_db.add_results(i, smi_dict, fragment_mass, j)
            smi_dict = None

        results_db.calculate_scores(i)

        if yield_smis:
            yield {ms["ms_id"]: results_db.get_structures(i)}

    if write_csv_output:
        results_db.generate_csv_output()

    db.close()
    results_db.close()


def generate_structures(ms_data: Union[str, os.PathLike, Dict[str, Dict[str, Union[int, None]]]],
                        path_substructure_db: Union[str, bytes, os.PathLike],
                        path_out: Union[str, bytes, os.PathLike] = os.path.realpath(os.getcwd()),
                        ha_min: Union[int, None] = 2,
                        ha_max: Union[int, None] = 9,
                        max_degree: int = 6,
                        max_atoms_available: int = 2,
                        max_n_substructures: int = 3,
                        max_bde: Union[float, None] = None,
                        ncpus: Union[int, None] = None,
                        path_connectivity_db: Union[str, bytes, os.PathLike, None] = None,
                        minimum_frequency: Union[int, None] = None,
                        yield_smis: bool = True,
                        isomeric_smiles: bool = False,
                        write_csv_output: bool = True,
                        retain_substructures: bool = False
                        ) -> Dict[str, Sequence[set]]:
    """
    Generate molecules of a given mass using chemical substructures and connectivity graphs. Can optionally take a
    "prescribed" fragment mass to further filter results. Final structures are returned as a list and/or written in
    text format. For the generation of structures from MSn data, see
    :py:meth:`metaboblend.build_structures.annotate_msn`.

    :param ms_data: A dictionary that must contain one item per fragmentation spectrum; the keys of the dictionary
        should be a unique ID for the query and the corresponding value must itself be a dictionary, containing the
        following:

        - "exact_mass": `float` (neutral mass of query) OR "precursor_mz": `float` (mz of precursor ion)
        - "mf": `[C, H, N, O, P, S]` (a list of 6 integers)
        - "precursor_type": `str` (e.g. "[M+H]+", required for calculating neutral masses from ion mzs)
        - (optional) "prescribed_mass": 'float' (neutral mass of substructure).

        The dictionary or MSP path is fed to :py:meth:`metaboblend.parse.parse_ms_data`. A single neutral substructure
        mass may be provided ("prescribed_mass") to guide the structure generation process.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param path_out: Folder to which the SQLite 3 results database and CSV outputs should be written.

    :param ha_min: The minimum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param ha_max: The maximum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single,
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have
        a total degree of 3.

    :param max_atoms_available: The maximum number of  atoms available of each substructure to be considered for
        building molecules. `atoms_available` refers to the number of atoms on a substructure involved in forming
        chemical bonds (e.g. single or double bonds). `atoms_available` are also limited by the extensivity of the
        supplied connectivity database.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single,
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have
        a total degree of 3.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. The max number
        of substructures is also limited by the extensivity of the supplied connectivity database.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`. If the path is None, the default connectivity
        database bundled with MetaboBlend will be used.

    :param ncpus: How many worker processes to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique. Defaults to None, in which case this filtering method is not applied.

    :param yield_smis: If True, yields a set of unique SMILEs string for each input molecule, else returns None.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :param write_csv_output: Whether to extract results from the SQLite3 database for deposition in CSV files.

    :param retain_substructures: Whether to record the substructures used to generate final structures.

    :return: For each input molecule, yields unique SMILEs strings (unless `yield_smis = False`).
    """

    if path_connectivity_db is None:
        path_connectivity_db = os.path.join(os.path.realpath(os.path.dirname(__file__)), "../data",
                                            "connectivity.sqlite")

    db = SubstructureDb(path_substructure_db, path_connectivity_db)

    results_db = ResultsDb(path_out, False, retain_substructures=retain_substructures)
    results_db.create_results_db()

    # prepare temporary table here - will only be generated once in case of multiple input
    table_name = gen_subs_table(
        db=db,
        ha_min=ha_min,
        ha_max=ha_max,
        max_degree=max_degree,
        max_atoms_available=max_atoms_available,
        minimum_frequency=minimum_frequency,
        max_mass=round(max([ms_data[ms_id]["exact_mass"] for ms_id in ms_data.keys()]))
    )

    for i, ms in enumerate(parse_ms_data(ms_data, False)):

        results_db.add_ms(ms_data, ms["ms_id"], i,
                          [None, ha_min, ha_max, max_atoms_available, max_degree, max_n_substructures, None,
                           isomeric_smiles])

        ppm = None
        prescribed_substructures = None

        try:
            if ms["prescribed_mass"] is not None:
                ppm = 0
                prescribed_substructures = get_possible_fragment_ions(ms["prescribed_mass"], db, table_name=table_name)

        except KeyError:
            ms["prescribed_mass"] = None

        smi_dict = build(
            mf=ms["mf"],
            exact_mass=ms["exact_mass"],
            max_n_substructures=max_n_substructures,
            prescribed_substructures=prescribed_substructures,
            ppm=ppm,
            table_name=table_name,
            ncpus=ncpus,
            isomeric_smiles=isomeric_smiles,
            db=db,
            tolerance=0.0001,
            max_bde=max_bde
        )

        results_db.add_results(i, smi_dict, ms["prescribed_mass"])
        smi_dict = None

        results_db.calculate_scores(i)

        if yield_smis:
            yield {ms["ms_id"]: results_db.get_structures(i)}

    if write_csv_output:
        results_db.generate_csv_output()

    db.close()
