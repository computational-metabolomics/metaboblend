#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright Â© 2019-2020 Jack Gisby, Ralf Weber
#
# This file is part of MetaboBlend.
#
# MetaboBlend is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MetaboBlend is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MetaboBlend.  If not, see <https://www.gnu.org/licenses/>.
#

import os
import copy
import numpy
import itertools
import multiprocessing
import networkx as nx
from functools import partial
from operator import itemgetter
from rdkit import Chem

from metaboblend.algorithms import subset_sum


def combine_mfs(precise_mass_grp, db, table_name, accuracy):
    """
    A wrapper for :py:meth:`metaboblend.databases.select_ecs` that instead takes a group of subsets, as generated by
    the second stage of :py:meth:`metaboblend.build_structures.subset_sum` in
    :py:meth:`metaboblend.build_structures.build`.

    :param precise_mass_grp: A list containing the masses of substructures identified by subset_sum.

    :param db: The :py:meth:`metaboblend.databases.SubstructureDb` in which to search for elemental compositions.

    :param table_name: The name of the table containing substructures in which to search for elemental compositions.

    :param accuracy: To which decimal places of accuracy results are to be limited to.

            * **1** Integer level
            * **0_0001** Four decimal places

    :return: If there are no elemental compositions for any of the masses in the group, then an empty list is returned.
    """

    ecs = []

    for i in range(len(precise_mass_grp)):
        atoms = db.select_mfs(precise_mass_grp[i], table_name, accuracy)

        if len(atoms) == 0:
            return []

        ecs.append(atoms)

    return ecs


def reindex_atoms(records):
    """
    Parses the libs of groups of substructures that are to be combined; the lib is a dictionary containing details
    about the substructure, as generated by :py:meth:`metaboblend.databases.get_substructure`. Combines the
    molecules into a single :py:meth:`rdkit.Chem.Mol` object and obtains details on their bonding properties.

    :param records: Takes a list of lib dictionaries that contain details on each substructure to be combined.

    :return: Returns a tuple containing a :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule, followed by information on the substructure bonding properties, including:

        * **atoms_available** A list of the indices of atoms that are available for bonding.

        * **atoms_to_remove** A list of the indices of dummy atoms that are to be removed in order to bond with other
        substructures.

        * **bond_types** A dictionary containing the indices of atoms that are available for bonding as keys and values
        detailing their bond types. See :py:meth:`metaboblend.build_structures.add_bonds`.
    """

    atoms_available, atoms_to_remove, index_atoms = [], [], []
    bond_types, all_bond_types = {}, {}
    c = 0

    for i, record in enumerate(records):

        idxs = []
        all_bond_types[i] = []

        for atom in record["mol"].GetAtoms():

            atom_idx = atom.GetIdx()

            new_idx = atom_idx + c
            idxs.append(new_idx)

            if atom_idx in record["degree_atoms"]:
                atoms_available.append(new_idx)

            if atom_idx in record["dummies"]:
                atoms_to_remove.append(new_idx)

            if atom_idx in record["bond_types"]:
                bond_types[new_idx] = record["bond_types"][atom_idx]
                all_bond_types[i] += record["bond_types"][atom_idx]

        index_atoms.append(idxs)
        c = idxs[-1] + 1

    # check that bond types add up - removes some mismatched configurations
    for i in range(len(records)):
        other_bonds = []
        for j in range(len(records)):
            if i != j:
                other_bonds += all_bond_types[j]

        for bond in all_bond_types[i]:
            if bond not in other_bonds:
                return None, atoms_available, atoms_to_remove, bond_types, True

    mol_comb = Chem.Mol()
    for record in records:
        mol_comb = Chem.CombineMols(mol_comb, record["mol"])

    return mol_comb, atoms_available, atoms_to_remove, bond_types, False


def add_bonds(mols, edges, atoms_available, bond_types, bond_enthalpies):
    """
    Takes a set of substructures and attempts to combine them together to generate a final structure. One of the last
    steps in the :py:meth:`metaboblend.build_structures.build` workflow.

    :param mols: A :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule.

    :param edges: The edges to use in order to join the substructures together, obtained from the connectivity database
        (:py:meth:`metaboblend.databases.create_isomorphism_database`).

    :param atoms_available: A list of the indices of atoms that are available for bonding.

    :param bond_types:  The type of bonds to be formed by dummy atoms - see :py:meth:`Chem.rdchem.BondType`. Is a
        dictionary whose keys are atom indices and values are bond types, as follows:

            * **1.0** Single

            * **1.5** Aromatic

            * **2.0** Double

    :param bond_enthalpies: Dictionary of bond enthalpies, as generated by
    :py:meth:`metaboblend.build_structures.get_bond_enthalpies`.

    :return: If unsuccessful, returns None, else returns an :py:meth:`rdkit.Chem.EditableMol` object containing
        the substructures combined into a final single molecule.
    """

    rdkit_bond_types = {1: Chem.rdchem.BondType.SINGLE,
                        1.5: Chem.rdchem.BondType.AROMATIC,
                        2: Chem.rdchem.BondType.DOUBLE}

    bond_types_copy = copy.deepcopy(bond_types)  # deep copy as we modify items within the dict

    g = nx.Graph()
    g.add_edges_from(edges)

    g = nx.relabel_nodes(g, dict(zip(sorted(g.nodes()), atoms_available)))

    total_bde = 0

    mol_edit = Chem.EditableMol(mols)
    for edge in g.edges():

        if edge[0] in bond_types_copy:
            bt_start = bond_types_copy[edge[0]]
        else:
            return None, None  # nested dummy

        if edge[1] in bond_types_copy:
            bt_end = bond_types_copy[edge[1]]
        else:
            return None, None  # nested dummy

        bond_matches = list(set(bt_start).intersection(bt_end))

        if len(bond_matches) == 0:
            return None, None

        bt_start.remove(bond_matches[0])
        bt_end.remove(bond_matches[0])

        try:  # try forming the specified bond
            mol_edit.AddBond(edge[0], edge[1], rdkit_bond_types[bond_matches[0]])
        except KeyError:
            return None, None  # unknown bond type

        # calculate bond dissociation energy of "formed" bonds for the structure
        try:
            total_bde += bond_enthalpies[bond_matches[0]][mols.GetAtomWithIdx(edge[0]).GetSymbol()][mols.GetAtomWithIdx(edge[1]).GetSymbol()]
        except (SyntaxError, TypeError):
            total_bde = None

    return mol_edit, total_bde


def get_possible_fragment_ions(neutral_fragment_mass, db, hydrogenation_allowance=None, ppm=None, tolerance=None, table_name=None):
    """
    Get possible fragment ions from a neutral mass. Either matches the mass exactly or does approximate matching
    (within the allowable absolute or relative tolerance).

    :param neutral_fragment_mass: The neutral mass of the MS fragment.

    :param hydrogenation_allowance: Searches for substructures within `+-hydrogenation_allowance` hydrogen masses for
        substructures. Substructures that are matched by the neutral fragment mass itself are considered "even" whereas
        those matched by the modified masses are considered "odd" (i.e. non-standard hydrogen re-arrangements). In the
        case of exact find, this field is left as None.

    :param db: Connection to the SQLite3 substructure database, :py:meth:`metaboblend.databases.SubstructureDb`.

    :param ppm: The relative (parts per million) tolerance for the neutral fragment mass. In the case of exact find,
        this field is ignored.

    :param tolerance: The minimum absolute mz tolerance for the neutral fragment mass. In the case of exact find, this
        field is ignored.

    :param table_name: Name of the substructures and substructure_ions tables to query. If None, uses the main tables.

    :return: A dictionary in the format:
        {integer_mass (int): {exact_mass (float): {substructure_id (int): substructure (dict)}}}.
    """

    if table_name is None:
        subs_table_name = "substructures"
        subs_ions_table_name = "substructure_ions"
    else:
        subs_table_name = table_name + "_substructures"
        subs_ions_table_name = table_name + "_substructure_ions"

    fragments = {}

    if hydrogenation_allowance is None:  # exact find

        exact_mass__1 = round(neutral_fragment_mass, 0)
        exact_mass_0_0001 = round(neutral_fragment_mass, 4)

        fragments[exact_mass__1] = {exact_mass_0_0001: {}}

        db.cursor.execute("""SELECT smiles, mol, bond_types, valence_atoms, valence, atoms_available, dummies, 
                                    C, H, N, O, P, S, substructure_id
                                 FROM {}
                                 WHERE exact_mass__0_0001 = {}
                          """.format(subs_table_name, exact_mass_0_0001))

        for record in db.cursor.fetchall():

            substructure = {
                "smiles": record[0],
                "mol": Chem.Mol(record[1]),
                "bond_types": eval(record[2]),
                "degree_atoms": eval(record[3]),
                "valence": record[4],
                "atoms_available": record[5],
                "dummies": eval(record[6]),
                "even": True,
                "mf": (record[7], record[8], record[9], record[10], record[11], record[12],)
            }

            fragments[exact_mass__1][exact_mass_0_0001][record[13]] = substructure

    else:  # approximate find +- hydrogens

        for i in range(0 - hydrogenation_allowance, hydrogenation_allowance + 1):

            hydrogenated_fragment_mass = neutral_fragment_mass + (i * 1.007825)  # consider non-standard re-arrangements

            if ((hydrogenated_fragment_mass / 1000000) * ppm) > tolerance:
                fragment_tolerance = round((hydrogenated_fragment_mass / 1000000) * ppm, 4)
            else:
                fragment_tolerance = tolerance

            db.cursor.execute("""SELECT smiles, mol, bond_types, valence_atoms, valence, atoms_available, dummies,
                                        exact_mass__0_0001, exact_mass__1, C, H, N, O, P, S, unmodified_substructures.substructure_id,
                                        modified_masses.modified_exact_mass__0_0001
                                     FROM {} AS unmodified_substructures
                                     LEFT JOIN {} AS modified_masses ON unmodified_substructures.substructure_id = modified_masses.substructure_id
                                     WHERE modified_masses.modified_exact_mass__0_0001 > {} AND modified_masses.modified_exact_mass__0_0001 < {}
                              """.format(
                                     subs_table_name,
                                     subs_ions_table_name,
                                     hydrogenated_fragment_mass - fragment_tolerance,
                                     hydrogenated_fragment_mass + fragment_tolerance
                                 ))

            for record in db.cursor.fetchall():

                substructure = {
                    "smiles": record[0],
                    "mol": Chem.Mol(record[1]),
                    "bond_types": eval(record[2]),
                    "degree_atoms": eval(record[3]),
                    "valence": record[4],
                    "atoms_available": record[5],
                    "dummies": eval(record[6]),
                    "even": i == 0,
                    "mf": (record[9], record[10], record[11], record[12], record[13], record[14],),
                    "ppm_error": abs(((hydrogenated_fragment_mass - record[16]) / hydrogenated_fragment_mass) * 1000000)
                }

                if record[8] not in fragments.keys():
                    fragments[record[8]] = {record[7]: {record[15]: substructure}}

                elif record[7] not in fragments[record[8]].keys():
                    fragments[record[8]][record[7]] = {record[15]: substructure}

                # if hydrogenation modifications have been made (i.e. i != 0) do not modify existing record
                elif record[15] not in fragments[record[8]][record[7]].keys() or i == 0:
                    fragments[record[8]][record[7]][record[15]] = substructure

    return fragments


def build(db, mf, exact_mass, max_n_substructures, prescribed_substructures, ppm, ncpus, table_name, isomeric_smiles,
          tolerance, max_bde):
    """
    Core function for generating molecules of a given mass using substructures and connectivity graphs. Can optionally
    take a "prescribed" fragment mass to further filter results; this can be used to incorporate MSn data. Final
    molecules are written to the specified file and/or returned in smiles format. This function represents the central
    building method used by MetaboBlend; :py:meth:`metaboblend.build_structures.generate_structures` provides a simple
    interface for generating structures of a given mass whilst
    :py:meth:`metaboblend.build_structures.annotate_msn` allows for the generation and scoring of structures using
    information from fragmentation spectra.

    :param db: Connection to the SQLite3 substructure database, :py:meth:`metaboblend.databases.SubstructureDb`.

    :param mf: List of integers detailing the molecular formula of the target metabolite, in the format
        [C, H, N, O, P, S].

    :param exact_mass: The exact mass (float) of the target metabolite.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules.

    :param prescribed_substructures: Substructures by which to filter results, as generated by
        :py:meth:`metaboblend.build_structures.get_possible_fragment_ions`.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param ncpus: How many CPUs to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param table_name: The table specified within the substructure database will be used to generate
        molecules. Will be removed after structures have been built, unless 'clean = False' is set.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :param tolerance: Minimum absolute mz tolerance for the fragment and precursor masses. Only used if
        `prescribed_substructures` is not None.

    :return: Returns a set of unique SMILEs strings.
    """

    configs_iso = db.k_configs()

    # select groups of masses at low mass resolution
    integer_mass_values = [m for m in db.select_mass_values("1", [], table_name) if m <= round(exact_mass, 0)]

    if os.name == "nt":  # multiprocessing freeze support on windows
        multiprocessing.freeze_support()

    substructure_subsets = []

    if prescribed_substructures is None:  # standard build method, does not require knowledge of a substructure of the target metabolite
        substructure_subsets = refine_masses_standard(substructure_subsets, mf, exact_mass, integer_mass_values, max_n_substructures, table_name, db)

    else:  # MSn build method - requires a list of possible substructures (prescribed_substructures)

        substructure_subsets = refine_masses_prescribed(substructure_subsets, mf, exact_mass, prescribed_substructures, ppm, integer_mass_values, max_n_substructures - 1, table_name, db, tolerance)

    with multiprocessing.Pool(processes=ncpus) as pool:  # send sets of substructures for building
        smi_dicts = pool.map(
            partial(substructure_combination_build, configs_iso=configs_iso,
                    prescribed_method=prescribed_substructures is not None, isomeric_smiles=isomeric_smiles,
                    bond_enthalpies=get_bond_enthalpies(), max_bde=max_bde),
            substructure_subsets
        )

    substructure_subsets = None

    # recombine the output of pool.map into a single dictionary
    smi_dict = {}
    for d in smi_dicts:
        for k in d.keys():
            try:
                smi_dict[k]["bde"] += d[k]["bde"]
                smi_dict[k]["valence"] += d[k]["valence"]
                smi_dict[k]["substructures"] += d[k]["substructures"]

                if prescribed_substructures is not None:
                    smi_dict[k]["even"] += d[k]["even"]
                    smi_dict[k]["ppm_error"] += d[k]["ppm_error"]

            except KeyError:
                smi_dict[k] = d[k]

    return smi_dict


def refine_masses_standard(substructure_subsets, mf, exact_mass, integer_mass_values, max_n_substructures, table_name,
                           db):
    """
    Takes a set of masses and applies :py:meth:`metaboblend.algorithms.subset_sum`. Generates a list of subsets of
    substructures to be combined into candidate target metabolites.

    :param substructure_subsets: List of substructure subsets to be filled, usually empty.

    :param integer_mass_values: List of possible integer masses for all valid substructures.

    :param max_n_substructures: The maximum number of substructures to be combined.

    :param table_name: The name of the table from which to extract substructures - if None, searches the main tables.

    :param db: Connection to the SQLite3 substructure database, :py:meth:`metaboblend.databases.SubstructureDb`.

    :param mf: List of integers detailing the molecular formula of the target metabolite, in the format
        [C, H, N, O, P, S].

    :param exact_mass: The exact mass (float) of the target metabolite.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules.

    :return: Returns a list of lists - one list for each substructure subset. Each substructure subset list contains
        a list for each
    """

    integer_subsets = list(subset_sum(integer_mass_values, int(round(exact_mass, 0)), max_n_substructures))

    for integer_subset in integer_subsets:

        if len(integer_subset) > max_n_substructures or len(integer_subset) == 0:
            continue

        # refine groups of masses to 4dp mass resolution
        exact_mass_values = db.select_mass_values("0_0001", integer_subset, table_name)

        # use combinations to get second group of masses instead of subset sum - subset sum is integer mass only
        exact_subsets = []
        for mass_combo in itertools.product(*exact_mass_values):
            if round(sum(mass_combo), 4) == round(exact_mass, 4):
                exact_subsets.append(mass_combo)

        if len(exact_subsets) == 0:
            continue

        # refines groups based on ecs and gets substructures from db (appends to substructure_subsets)
        for exact_subset in exact_subsets:
            substructure_subsets += build_from_subsets(exact_subset, mf=mf, table_name=table_name, db=db)

    return substructure_subsets


def refine_masses_prescribed(substructure_subsets, mf, exact_mass, prescribed_substructures, ppm, integer_mass_values,
                             max_n_substructures, table_name, db, tolerance):
    """
    Takes a set of masses and applies :py:meth:`metaboblend.algorithms.subset_sum`. Generates a list of subsets of
    substructures to be combined with possible fragment substructures to generate candidate target metabolites.

    :param prescribed_substructures: Substructures that may represent the neutral fragment structure, as retrieved
        by :py:meth:`metaboblend.build_structures.get_possible_fragment_ions`.

    :param substructure_subsets: List of substructure subsets to be filled, usually empty.

    :param integer_mass_values: List of possible integer masses for all valid substructures.

    :param max_n_substructures: The maximum number of substructures to be combined.

    :param table_name: The name of the table from which to extract substructures - if None, searches the main tables.

    :param db: Connection to the SQLite3 substructure database, :py:meth:`metaboblend.databases.SubstructureDb`.

    :param mf: List of integers detailing the molecular formula of the target metabolite, in the format
        [C, H, N, O, P, S].

    :param exact_mass: The exact mass (float) of the target metabolite.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. Note that this
        does not include the fragment substructure itself.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param tolerance: Minimum absolute mz tolerance for the fragment and precursor masses. Only used if
        `prescribed_substructures` is not None.

    :return: Returns a list of lists - one list for each substructure subset. Each substructure subset list contains
        a list for each
    """

    # for each fragment peak in the MS2 spectrum
    for fragment_mass__1 in prescribed_substructures.keys():

        # work out the corresponding neutral loss
        loss_mass__1 = int(round(round(exact_mass, 0) - fragment_mass__1, 0))

        if ((exact_mass / 1000000) * ppm) > tolerance:
            tolerance = round((exact_mass / 1000000) * ppm, 4)

        if len(integer_mass_values) == 0:
            return {}

        # get subsets of masses at integer level that could build up to the loss mass (i.e. can be combined with fragment substructure(s))
        integer_subsets = list(subset_sum(integer_mass_values, loss_mass__1, max_n_substructures))

        for integer_subset in integer_subsets:

            if len(integer_subset) > max_n_substructures or len(integer_subset) == 0:
                continue

            # refine groups of (loss) masses to 4dp mass resolution
            exact_mass_values = db.select_mass_values("0_0001", integer_subset, table_name)

            for fragment_mass_0_0001 in prescribed_substructures[fragment_mass__1].keys():

                # use combinations to get second group of masses instead of subset sum - subset sum is integer mass only
                exact_subsets = []
                for mass_combo in itertools.product(*exact_mass_values):
                    if abs((fragment_mass_0_0001 + sum(mass_combo)) - exact_mass) <= tolerance:
                        exact_subsets.append(mass_combo)

                if len(exact_subsets) == 0:
                    continue

                # refines groups based on ecs and gets substructures from db (appends to substructure_subsets)
                mf_to_substructure_id = {}
                for substructure_id in prescribed_substructures[fragment_mass__1][fragment_mass_0_0001].keys():
                    try:
                        mf_to_substructure_id[tuple(prescribed_substructures[fragment_mass__1][fragment_mass_0_0001][substructure_id]["mf"])].append(substructure_id)
                    except KeyError:
                        mf_to_substructure_id[tuple(prescribed_substructures[fragment_mass__1][fragment_mass_0_0001][substructure_id]["mf"])] = [substructure_id]

                for fragment_mf in mf_to_substructure_id.keys():
                    for exact_subset in exact_subsets:

                        loss_mf = [atom - fragment_atom for atom, fragment_atom in zip(mf, fragment_mf)]

                        substructure_subsets += build_from_subsets(
                            exact_subset,
                            mf=loss_mf,
                            table_name=table_name,
                            db=db,
                            fragment_substructures=[prescribed_substructures[fragment_mass__1][fragment_mass_0_0001][substructure_id] for substructure_id in mf_to_substructure_id[fragment_mf]]
                        )

    return substructure_subsets


def gen_subs_table(db, ha_min, ha_max, max_degree, max_atoms_available, max_mass, table_name="subset",
                   minimum_frequency=None):
    """
    Generate a temporary secondary substructure table restricted by a set of parameters. Generated as an initial step
    in :py:meth:`metaboblend.build_structures.generate_structures` and
    :py:meth:`metaboblend.build_structures.annotate_msn` in order to limit the processing overhead as a result of
    repeatedly querying the SQLite substructure database.

    :param max_mass: The maximum allowed mass of substructures in the temporary table; there is no point considering
        substructures with greater mass than the target mol.

    :param db: Connection to a :py:meth:`metaboblend.databases.SubstructureDb` from which to extract substructures.

    :param ha_min: Minimum value of `heavy_atoms` for substructures to be transferred into the temporary table.
        If None, no limit is applied.

    :param ha_max: Maximum value of `heavy_atoms` for substructures to be transferred into the temporary table.
        If None, no limit is applied.

    :param max_degree: The maximum total valence (ie, the product of `atoms_available` and the degree of their bonds)
        to be included in the temporary table.

    :param max_atoms_available: The maximal atoms available of substructures to be included in the temporary table.

    :param table_name: Defaults to "subset_substructures", which is cleaned up upon database closure. The name of the
        table to be generated

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique.

    :return: The name of the temporary secondary substructure table.
    """

    db.cursor.execute("DROP TABLE IF EXISTS %s" % (table_name + "_substructures"))
    db.cursor.execute("DROP TABLE IF EXISTS %s" % (table_name + "_substructure_ions"))

    if minimum_frequency is None:
        freq_statement = ""
    else:
        freq_statement = """
                            AND smiles IN 
                                (SELECT smiles 
                                    FROM hmdbid_substructures 
                                    GROUP BY smiles 
                                    HAVING COUNT(*) >= {})
                         """.format(minimum_frequency,)

    if ha_min is None:
        ha_min_statement = ""
    else:
        ha_min_statement = """
                              AND heavy_atoms >= %s""" % str(ha_min)

    if ha_max is None:
        ha_max_statement = ""
    else:
        ha_max_statement = """
                              AND heavy_atoms <= %s""" % str(ha_max)

    if max_mass is None:
        max_mass_statement = ""
    else:
        max_mass_statement = """
                                AND exact_mass__1 < %s""" % str(max_mass)

    db.temporary_table_names.append(table_name + "_substructures")

    db.cursor.execute("""CREATE TABLE {} (
                               substructure_id INTEGER PRIMARY KEY,
                               smiles TEXT NOT NULL UNIQUE, 
                               heavy_atoms INTEGER,
                               length INTEGER,
                               exact_mass__1 INTEGER,
                               exact_mass__0_0001 REAL,
                               exact_mass REAL,
                               C INTEGER,
                               H INTEGER,
                               N INTEGER,
                               O INTEGER,
                               P INTEGER,
                               S INTEGER,
                               valence INTEGER,
                               valence_atoms TEXT,
                               atoms_available INTEGER,
                               bond_types TEXT,
                               dummies TEXT,
                               mol BLOB)
                      """.format(
                               table_name + "_substructures",
                               table_name + "_substructure_ions"
                         ))

    db.cursor.execute("""INSERT INTO {}
                             SELECT * 
                                 FROM substructures
                                 WHERE atoms_available <= {}
                                 AND valence <= {}{}{}{}{}
                      """.format(
                             table_name + "_substructures",
                             max_atoms_available,
                             max_degree,
                             max_mass_statement,
                             freq_statement,
                             ha_min_statement,
                             ha_max_statement
                      ))

    db.temporary_table_names.append(table_name + "_substructure_ions")

    db.cursor.execute("""CREATE TABLE {}_substructure_ions (
                               substructure_id INTEGER, 
                               hydrogen_modification INTEGER, 
                               ion_mode_positive BOOLEAN,
                               modified_exact_mass__1 INTEGER, 
                               modified_exact_mass__0_0001 REAL,
                               PRIMARY KEY (substructure_id, hydrogen_modification, ion_mode_positive),
                               FOREIGN KEY (substructure_id) REFERENCES {}_substructures(substructure_id))
                      """.format(table_name, table_name))

    db.cursor.execute("""INSERT INTO {}
                             SELECT *
                                 FROM substructure_ions
                                 WHERE substructure_id IN (SELECT substructure_id FROM {})
                      """.format(
                             table_name + "_substructure_ions",
                             table_name + "_substructures"
                         ))

    db.conn.commit()
    db.create_temp_indexes(table_name)

    return table_name


def build_from_subsets(exact_subset, mf, table_name, db, fragment_substructures=None):
    """
    A stage of the :py:meth:`metaboblend.build_structures.build` workflow for generating molecules to a given mass
    from substructures. At this stage, mass subsets have been identified in the substructure database. Each of these
    groups are now filtered further by identifying masses that refer to valid subsets of molecules, before they are
    built to generate new molecules.

    :param db: The substructure and connectivity database. Elemental compositions and substructures are retrieved from
        the database; this information is listed as "substructure_subset" and will be appended to the
        substructure_subsets list provided as a parameter.

    :param exact_subset: Group of masses that sum to the correct total mass, refer to substructures in the substructure
        database.

    :param mf: List of integers detailing the molecular composition of the target metabolite, in the format
        `[C, H, N, O, P, S]`.

    :param table_name: The name of the table within the substructure database from which to extract substructures. A
        prefiltered table based on the parameters specified in :py:meth:`metaboblend.build_structures.build`. See
        :py:meth:`metaboblend.build_structures.gen_subs_table`.

    :param fragment_substructures: If None, standard building from the input mass subset is carried out. Else,
        represents the retrieved candidate fragment substructures to be combined with the substructures of the input
        mass subset.

    :return: Returns a list in the same format as the input mass subset, `exact_subset`. Instead of masses (floats),
        the substructures are now represented by dictionaries, as retreived by
        :py:meth:`metaboblend.build_structures.get_possible_fragment_ions`.
    """

    substructure_subsets = []
    mf_subset = combine_mfs(exact_subset, db, table_name, "0_0001")

    if len(mf_subset) == 0:
        return []

    for ec_product in itertools.product(*mf_subset):

        if mf != list(numpy.array(ec_product).sum(axis=0)):
            continue  # check each set of elemental compositions matches the target mol

        substructure_subset = db.select_substructures(ec_product, table_name)

        if len(substructure_subset) == 0:
            continue

        if fragment_substructures is None:
            substructure_subsets.append(substructure_subset)
        else:
            substructure_subsets.append([fragment_substructures] + substructure_subset)

    return substructure_subsets


def get_bond_enthalpies():
    """ Gets predicted bond dissociation energies for each bond type and elemental composition. """

    return {1.0: {'C': {'C':  348, 'N':  305, 'O':  360, 'P':  264, 'S':  272},
                  'N': {'C':  305, 'N':  163, 'O':  222, 'P': None, 'S': None},
                  'O': {'C':  360, 'N':  222, 'O':  146, 'P':  335, 'S': None},
                  'P': {'C':  264, 'N': None, 'O':  335, 'P':  201, 'S': None},
                  'S': {'C':  272, 'N': None, 'O': None, 'P': None, 'S':  226}},
            1.5: {'C': {'C':  837, 'N':  890, 'O': None, 'P': None, 'S': None},
                  'N': {'C':  890, 'N':  944, 'O': None, 'P': None, 'S': None},
                  'O': {'C': None, 'N': None, 'O': None, 'P': None, 'S': None},
                  'P': {'C': None, 'N': None, 'O': None, 'P': None, 'S': None},
                  'S': {'C': None, 'N': None, 'O': None, 'P': None, 'S': None}},
            2.0: {'C': {'C':  612, 'N':  613, 'O':  743, 'P': None, 'S':  573},
                  'N': {'C':  613, 'N':  409, 'O':  607, 'P': None, 'S': None},
                  'O': {'C':  743, 'N':  607, 'O':  496, 'P':  544, 'S':  522},
                  'P': {'C': None, 'N': None, 'O':  544, 'P': None, 'S':  335},
                  'S': {'C':  573, 'N': None, 'O':  522, 'P':  335, 'S':  425}}}


def substructure_combination_build(substructure_subset, configs_iso, prescribed_method, isomeric_smiles,
                                   bond_enthalpies, max_bde):
    """
    Final stage for building molecules; takes a combination of substructures (substructure_combination) and builds them
    according to graphs in the substructure database. May be run in parallel.

    :param substructure_subset: Combinations of substructures for building mols.

    :param configs_iso: Possible substructure combinations extracted from the connectivity database. A tuple containing
        tuples for each substructure; these tuples specify how many bonds each substructure can make.

    :param prescribed_method: If True, assumes the first substructure in `substructure_subset` to be the fragment
        substructure.

    :param isomeric_smiles: True/False, should output smiles be written with isomeric information?

    :param bond_enthalpies: Dictionary of bond enthalpies, as generated by
    :py:meth:`metaboblend.build_structures.get_bond_enthalpies`.

    :param retain_substructures: Whether to record the substructures used to generate final structures.

    :return: List of smiles representing molecules generated (and the substructures used to generate them).
    """

    smis = {}

    for substructure_combination in itertools.product(*substructure_subset):

        total_valence = substructure_combination[0]["valence"]

        if prescribed_method:
            substructure_combination[0]["fragment"] = True
            even_fragment = substructure_combination[0]["even"]

            if "ppm_error" in substructure_combination[0].keys():
                ppm_error = substructure_combination[0]["ppm_error"]
            else:
                ppm_error = None

        substructure_combination = sorted(substructure_combination, key=itemgetter('atoms_available', 'valence'))

        v_a = ()
        j = -1

        if prescribed_method:
            fragment_indexes = []

        for i, d in enumerate(substructure_combination):

            v_a += (tuple(d["degree_atoms"].values()),)  # obtain valence configuration of the set of substructures

            for atom_available in tuple(d["degree_atoms"].values()):
                j += 1

                try:
                    if prescribed_method:
                        if d["fragment"]:
                            fragment_indexes.append(j)

                except KeyError:
                    continue

        if str(v_a) not in configs_iso:  # check mols "fit" together according to the connectivity database
            continue

        mol_comb, atoms_available, atoms_to_remove, bond_types, bond_mismatch = reindex_atoms(substructure_combination)

        if bond_mismatch:
            continue  # check that bond types are compatible (imperfect check)

        for edges in configs_iso[str(v_a)]:  # build mols for each graph in connectivity db
            if prescribed_method:
                non_fragment_edges = False

                for edge in edges:  # check that edges only connect to fragment ion
                    if edge[0] not in fragment_indexes and edge[1] not in fragment_indexes:
                        non_fragment_edges = True

                if non_fragment_edges:
                    continue

            # add bonds between substructures
            mol_e, total_bde = add_bonds(mol_comb, edges, atoms_available, bond_types, bond_enthalpies)

            if mol_e is None or total_bde is None:
                continue
            elif max_bde is not None:
                if total_bde > max_bde:
                    continue

            atoms_to_remove.sort(reverse=True)
            [mol_e.RemoveAtom(a) for a in atoms_to_remove]  # clean up dummy atoms

            mol_out = mol_e.GetMol()  # generate the final (non-editable) mol

            try:
                Chem.SanitizeMol(mol_out)  # clean the mol - ensure it is valid & canonical
            except:
                continue

            try:  # append the canonical smiles of the final structure
                final_structure = Chem.MolToSmiles(mol_out, isomericSmiles=isomeric_smiles)

            except RuntimeError:
                continue  # bad bond type violation

            final_substructures = [subs["smiles"] for subs in substructure_combination]

            # add required information to a dictionary
            try:
                smis[final_structure]["bde"].append(total_bde)
                smis[final_structure]["valence"].append(total_valence)

                smis[final_structure]["substructures"].append(final_substructures)

                if prescribed_method:
                    smis[final_structure]["even"].append(even_fragment)

                    if ppm_error is not None:
                        smis[final_structure]["ppm_error"].append(ppm_error)

            except KeyError:
                smis[final_structure] = {"bde": [total_bde], "valence": [total_valence]}

                if prescribed_method:
                    smis[final_structure]["even"] = [even_fragment]

                    if ppm_error is not None:
                        smis[final_structure]["ppm_error"] = [ppm_error]

                smis[final_structure]["substructures"] = [final_substructures]

    return smis
