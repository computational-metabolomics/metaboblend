#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright Â© 2019-2020 Ralf Weber
#
# This file is part of MetaboBlend.
#
# MetaboBlend is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MetaboBlend is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MetaboBlend.  If not, see <https://www.gnu.org/licenses/>.
#

import os
import multiprocessing
import copy
import itertools
from functools import partial
import networkx as nx
import numpy
import sqlite3
from operator import itemgetter
from typing import Sequence, Dict, Union

from rdkit import Chem

from .databases import SubstructureDb, get_elements, calculate_exact_mass


def find_path(mass_list, sum_matrix, n, mass, max_subset_length, path=[]):
    """
    Recursive solution for backtracking through the dynamic programming boolean matrix. All possible subsets are found

    :param mass_list: A list of masses from which to identify subsets.

    :param mass: The target mass of the sum of the substructures.

    :param sum_matrix: The dynamic programming boolean matrix.

    :param n: The size of mass_list.

    :param max_subset_length: The maximum length of subsets to return. Allows the recursive backtracking algorithm to
        terminate early in many cases, significantly improving runtime.

    :param path: List for keeping track of the current subset.

    :return: Generates of lists containing the masses of valid subsets.
    """

    # base case - the path has generated a correct solution
    if mass == 0:
        yield sorted(path)
        return

    # stop running when we overshoot the mass
    elif mass < 0:
        return

    # can we sum up to the target value using the remaining masses? recursive call
    elif sum_matrix[n][mass]:
        yield from find_path(mass_list, sum_matrix, n - 1, mass, max_subset_length, path)

        if len(path) < max_subset_length:
            path.append(mass_list[n-1])

            yield from find_path(mass_list, sum_matrix, n - 1, mass - mass_list[n - 1], max_subset_length, path)
            path.pop()


def subset_sum(mass_list, mass, max_subset_length=3):
    """
    Dynamic programming implementation of subset sum. Note that, whilst this algorithm is pseudo-polynomial, the
    backtracking algorithm for obtaining all possible subsets has exponential complexity and so remains unsuitable
    for large input values.  This does, however, tend to perform a lot better than non-sum_matrix implementations, as
    we're no longer doing sums multiple times and we've cut down the operations performed during the exponential portion
    of the method.

    :param mass_list: A list of masses from which to identify subsets.

    :param mass: The target mass of the sum of the substructures.

    :param max_subset_length: The maximum length of subsets to return. Allows the recursive backtracking algorithm to
        terminate early in many cases, significantly improving runtime.

    :return: Generates of lists containing the masses of valid subsets.
    """

    n = len(mass_list)

    # initialise dynamic programming array
    sum_matrix = numpy.ndarray([n + 1, mass + 1], bool)

    # subsets can always equal 0
    for i in range(n+1):
        sum_matrix[i][0] = True

    # empty subsets do not have non-zero sums
    for i in range(mass):
        sum_matrix[0][i + 1] = False

    # fill in the remaining boolean matrix
    for i in range(n):
        for j in range(mass+1):
            if j >= mass_list[i]:
                sum_matrix[i + 1][j] = sum_matrix[i][j] or sum_matrix[i][j - mass_list[i]]
            else:
                sum_matrix[i + 1][j] = sum_matrix[i][j]

    # backtrack through the matrix recursively to obtain all solutions
    return find_path(mass_list, sum_matrix, n, mass, max_subset_length)


def combine_mfs(precise_mass_grp, db, table_name, accuracy):
    """
    A wrapper for :py:meth:`metaboblend.databases.select_ecs` that instead takes a group of subsets, as generated by
    the second stage of :py:meth:`metaboblend.build_structures.subset_sum` in
    :py:meth:`metaboblend.build_structures.build`.

    :param precise_mass_grp: A list containing the masses of substructures identified by subset_sum.

    :param db: The :py:meth:`metaboblend.databases.SubstructureDb` in which to search for elemental compositions.

    :param table_name: The name of the table containing substructures in which to search for elemental compositions.

    :param accuracy: To which decimal places of accuracy results are to be limited to.

            * **1** Integer level
            * **0_0001** Four decimal places

    :return: If there are no elemental compositions for any of the masses in the group, then an empty list is returned.
    """

    ecs = []

    for i in range(len(precise_mass_grp)):
        atoms = db.select_mfs(precise_mass_grp[i], table_name, accuracy)

        if len(atoms) == 0:
            return []

        ecs.append(atoms)

    return ecs


def reindex_atoms(records):
    """
    Parses the libs of groups of substructures that are to be combined; the lib is a dictionary containing details
    about the substructure, as generated by :py:meth:`metaboblend.databases.get_substructure`. Combines the
    molecules into a single :py:meth:`rdkit.Chem.Mol` object and obtains details on their bonding properties.

    :param records: Takes a list of lib dictionaries that contain details on each substructure to be combined.

    :return: Returns a tuple containing a :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule, followed by information on the substructure bonding properties, including:

        * **atoms_available** A list of the indices of atoms that are available for bonding.

        * **atoms_to_remove** A list of the indices of dummy atoms that are to be removed in order to bond with other
        substructures.

        * **bond_types** A dictionary containing the indices of atoms that are available for bonding as keys and values
        detailing their bond types. See :py:meth:`metaboblend.build_structures.add_bonds`.
    """

    atoms_available, atoms_to_remove, bond_types = [], [], {}
    mol_comb = Chem.Mol()
    index_atoms, all_bond_types = [], {}
    c = 0

    for i, record in enumerate(records):
        idxs = []
        all_bond_types[i] = []
        for atom in record["mol"].GetAtoms():

            new_idx = atom.GetIdx() + c
            idxs.append(new_idx)

            if atom.GetIdx() in record["degree_atoms"]:
                atoms_available.append(new_idx)

            if atom.GetIdx() in record["dummies"]:
                atoms_to_remove.append(new_idx)

            if atom.GetIdx() in record["bond_types"]:
                bond_types[new_idx] = record["bond_types"][atom.GetIdx()]
                all_bond_types[i] += record["bond_types"][atom.GetIdx()]

        mol_comb = Chem.CombineMols(mol_comb, record["mol"])
        index_atoms.append(idxs)
        c = idxs[-1] + 1

    # check that bond types add up - removes some mismatched configurations
    bond_mismatch = False
    for i in range(len(records)):
        other_bonds = []
        for j in range(len(records)):
            if i != j:
                other_bonds += all_bond_types[j]

        for bond in all_bond_types[i]:
            if bond not in other_bonds:
                bond_mismatch = True

    return mol_comb, atoms_available, atoms_to_remove, bond_types, bond_mismatch


def add_bonds(mols, edges, atoms_available, bond_types):
    """
    Takes a set of substructures and attempts to combine them together to generate a final structure. One of the last
    steps in the :py:meth:`metaboblend.build_structures.build` workflow.

    :param mols: A :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule.

    :param edges: The edges to use in order to join the substructures together, obtained from the connectivity database
        (:py:meth:`metaboblend.databases.create_isomorphism_database`).

    :param atoms_available: A list of the indices of atoms that are available for bonding.

    :param bond_types:  The type of bonds to be formed by dummy atoms - see :py:meth:`Chem.rdchem.BondType`. Is a
        dictionary whose keys are atom indices and values are bond types, as follows:

            * **1.0** Single

            * **1.5** Aromatic

            * **2.0** Double

    :return: If unsuccessful, returns None, else returns an :py:meth:`rdkit.Chem.EditableMol` object containing
        the substructures combined into a final single molecule.
    """

    rdkit_bond_types = {1: Chem.rdchem.BondType.SINGLE,
                        1.5: Chem.rdchem.BondType.AROMATIC,
                        2: Chem.rdchem.BondType.DOUBLE}

    g = nx.Graph()
    g.add_edges_from(edges)

    g = nx.relabel_nodes(g, dict(zip(sorted(g.nodes()), atoms_available)))

    mol_edit = Chem.EditableMol(mols)
    for edge in g.edges():

        if edge[0] in bond_types:
            bt_start = copy.copy(bond_types[edge[0]])
        else:
            return None  # nested dummy

        if edge[1] in bond_types:
            bt_end = copy.copy(bond_types[edge[1]])
        else:
            return None  # nested dummy

        bond_matches = list(set(bt_start).intersection(bt_end))

        if len(bond_matches) == 0:
            return None

        else:
            bt_start.remove(bond_matches[0])
            bt_end.remove(bond_matches[0])

        try:
            mol_edit.AddBond(edge[0], edge[1], rdkit_bond_types[bond_matches[0]])
        except KeyError:
            return None  # unknown bond type

    return mol_edit


class ResultsDb:
    """
    Methods for interacting with the SQLITE3 results database, as created by
    :py:meth:`metaboblend.build_structures.annotate_msn`.

    :param path_results_db: Path to the results database.
    """

    def __init__(self, path_results_db, msn=True):
        """Constructor method."""

        self.path_results_db = path_results_db
        self.msn = msn

        self.conn = None
        self.cursor = None

    def connect(self):
        """Connects to the results database."""

        self.conn = sqlite3.connect(self.path_results_db)
        self.cursor = self.conn.cursor()

    def create_results_db(self):
        """Generates a new results database."""

        if os.path.exists(self.path_results_db):
            os.remove(self.path_results_db)

        self.connect()

        self.cursor.execute("""CREATE TABLE queries (
                                   ms_id TEXT PRIMARY KEY,
                                   exact_mass NUMERIC,
                                   C INTEGER,
                                   H INTEGER,
                                   N INTEGER,
                                   O INTEGER,
                                   P INTEGER,
                                   S INTEGER,
                                   ppm INTEGER,
                                   ha_min INTEGER,
                                   ha_max INTEGER,
                                   max_atoms_available INTEGER,
                                   max_degree INTEGER,
                                   max_n_substructures INTEGER,
                                   hydrogenation_allowance INTEGER,
                                   isomeric_smiles INTEGER)""")

        if self.msn:
            self.cursor.execute("""CREATE TABLE spectra (
                                       ms_id TEXT,
                                       fragment_id NUMERIC,
                                       neutral_mass NUMERIC,
                                       PRIMARY KEY (ms_id, fragment_id))""")

        self.cursor.execute("""CREATE TABLE structures (
                                   ms_id TEXT,
                                   smiles TEXT,
                                   frequency NUMERIC,
                                   exact_mass NUMERIC,
                                   C INTEGER,
                                   H INTEGER,
                                   N INTEGER,
                                   O INTEGER,
                                   P INTEGER,
                                   S INTEGER,
                                   PRIMARY KEY (ms_id, smiles))""")

        self.cursor.execute("""CREATE TABLE substructures (
                                           structure_smiles TEXT ,
                                           substructure_smiles TEXT,
                                           PRIMARY KEY (structure_smiles, substructure_smiles))""")

        self.cursor.execute("""CREATE TABLE results (
                                   ms_id TEXT,
                                   fragment_id NUMERIC,
                                   structure_smiles TEXT,
                                   PRIMARY KEY(ms_id, fragment_id, structure_smiles))""")

        self.conn.commit()

    def add_ms(self, msn_data, parameters):
        """
        Add entries to the `queries` and `spectra` tables.

        :param msn_data: Dictionary in the form
            `msn_data[id] = {mf: [C, H, N, O, P, S], exact_mass: float, fragment_masses: []}`. id represents a unique
            identifier for a given spectral tree or fragmentation spectrum, mf is a list of integers referring to the
            molecular formula of the structure of interest, exact_mass is the mass of this molecular formula to >=4d.p.
            and fragment_masses are neutral fragment masses generated by this structure used to inform candidate
            scoring. See :py:meth:`metaboblend.build_structures.annotate_msn`.

        :param parameters: List of parameters, in the form: [ppm, ha_min, ha_max, max_atoms_available, max_degree,
            max_n_substructures, hydrogenation_allowance, isomeric_smiles]. See
            :py:meth:`metaboblend.build_structures.annotate_msn`.
        """

        for i, parameter in enumerate(parameters):
            if parameter is None:
                parameters[i] = "NULL"
            elif isinstance(parameter, bool):
                parameters[i] = int(parameter)

        for ms_id in msn_data.keys():

            self.cursor.execute("""INSERT INTO queries (
                                       ms_id,
                                       exact_mass,
                                       C, H, N, O, P, S,
                                       ppm,
                                       ha_min,
                                       ha_max,
                                       max_atoms_available,
                                       max_degree,
                                       max_n_substructures,
                                       hydrogenation_allowance,
                                       isomeric_smiles
                                   ) VALUES ('{}', {}, '{}', '{}', '{}', '{}', '{}', '{}', {})""".format(
                                       ms_id,
                                       msn_data[ms_id]["exact_mass"],
                                       msn_data[ms_id]["mf"][0], msn_data[ms_id]["mf"][1],
                                       msn_data[ms_id]["mf"][2], msn_data[ms_id]["mf"][3],
                                       msn_data[ms_id]["mf"][4], msn_data[ms_id]["mf"][5],
                                       ", ".join([str(p) for p in parameters])
                                   ))

        self.conn.commit()

    def add_smis(self, ms_id, smis, fragment_mass):
        """
        Record which smiles were generated for a given fragment mass.

        :param ms_id: Unique identifer for the annotation of a single metabolite.

        :param smis: The smiles generated by the annotation of a single peak for a single metabolite.

        :param fragment_mass: The neutral fragment mass that has been annotated.
        """

        self.cursor.executemany("INSERT OR IGNORE INTO {} (smiles) VALUES (?)".format(ms_id), [[smi] for smi in smis])

        self.cursor.execute("UPDATE {} SET '{}' = 1 WHERE smiles IN ('{}')".format(ms_id,
                                                                                   str(fragment_mass),
                                                                                   "', '".join(smis)))

        self.conn.commit()

    def calc_scores(self, ms_id, fragment_masses):
        """
        Calculate number of peaks for which a given structure was generated.

        :param ms_id: Unique identifer for the annotation of a single metabolite.

        :param fragment_masses: The neutral fragment masses that have been annotated.
        """

        self.cursor.execute("UPDATE {} SET peak_sum = [{}]".format(
            ms_id,
            "] + [".join([str(fragment_mass) for fragment_mass in fragment_masses])
        ))

        self.conn.commit()

    def structure_frequency(self, ms_id):
        """
        Generate a dictionary of results with structure frequencies.

        :param ms_id: Unique identifer for the annotation of a single metabolite.

        :return: A dictionary with smiles as keys and the number of peaks for which the smiles were generated as
        values
        """

        structure_frequencies = {}
        for smiles, peak_sum in self.cursor.execute("""SELECT smiles, peak_sum FROM {}""".format(ms_id)):
            structure_frequencies[smiles] = peak_sum

        return structure_frequencies

    def close(self):
        """Close the connection to the SQLITE3 database"""

        self.conn.close()


def annotate_msn(msn_data: Dict[str, Dict[str, Union[int, list]]],
                 path_substructure_db: Union[str, bytes, os.PathLike],
                 path_sql_out: Union[str, bytes, os.PathLike] = "metaboblend_results.sqlite",
                 ppm: int = 5,
                 ha_min: Union[int, None] = None,
                 ha_max: Union[int, None] = None,
                 max_atoms_available: int = 2,
                 max_degree: int = 6,
                 max_n_substructures: int = 3,
                 path_connectivity_db: Union[str, bytes, os.PathLike, None] = None,
                 ncpus: Union[int, None] = None,
                 minimum_frequency: Union[int, None] = None,
                 hydrogenation_allowance: int = 2,
                 yield_smi_dict: bool = True,
                 isomeric_smiles: bool = False
                 ) -> Dict[str, Sequence[Dict[str, int]]]:
    """
    Generate molecules of a given mass using chemical substructures, connectivity graphs and spectral trees or
    fragmentation spectra. Final structures and rankings are yielded by the function as a dictionary and/or written in
    text format. For the generation of structures without MSn data, see
    :py:meth:`metaboblend.build_structures.generate_structures`.

    :param msn_data: Dictionary in the form
        `msn_data[id] = {mf: [C, H, N, O, P, S], exact_mass: float, fragment_masses=[]}`. id represents a unique
        identifier for a given spectral tree or fragmentation spectrum, mf is a list of integers referring to the
        molecular formula of the structure of interest, exact_mass is the mass of this molecular formula to >=4d.p.
        and fragment_masses are neutral fragment masses generated by this structure used to inform candidate scoring.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param path_sql_out: The path at which an SQLite database will be generated to store results.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param ha_min: The minimum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param ha_max: The maximum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param max_atoms_available: The maximum number of  atoms available of each substructure to be considered for
        building molecules. `atoms_available` refers to the number of atoms on a substructure involved in forming
        chemical bonds (e.g. single or double bonds). `atoms_available` are also limited by the extensivity of the
        supplied connectivity database.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single, 
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For 
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have 
        a total degree of 3.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. The max number
        of substructures is also limited by the extensivity of the supplied connectivity database.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`. If the path is None, the default connectivity
        database bundled with MetaboBlend will be used.

    :param ncpus: How many CPUs to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique. Defaults to None, in which case this filtering method is not applied.

    :param hydrogenation_allowance: In order to represent re-arrangement events (the movement of hydrogens), in
        addition to attempting to build from substructures in prescribed_masses, we also attempt to build from
        `fragment_masses +- hydrogenation_allowance`. E.g. if `prescribed_masses = [141.5938]` and
        `hydrogenation_allowance = 1` then, to find candidate fragment substructures, we use as query the masses
        `[141.5938 - 1.007825, 141.5938, 141.5938 + 1.007825]`.

    :param yield_smi_dict: If True, for each input molecule the function yields a dictionary whose keys are SMILEs
        strings and values are the number of `fragment_masses` by which the structure was generated. Else, returns None.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :return: For each input molecule yields a dictionary whose keys are SMILEs strings for the generated
        structures and values are the number of `fragment_masses` by which the structure was built (unless
        `yield_smi_dict = False`).
    """

    if ppm is None:
        ppm = 0

    if path_connectivity_db is None:
        path_connectivity_db = os.path.join(os.path.realpath(os.path.dirname(__file__)), "data", "connectivity.sqlite")

    db = SubstructureDb(path_substructure_db, path_connectivity_db)
    results_db = ResultsDb(path_sql_out)
    results_db.create_results_table()

    # prepare temporary table here - will only be generated once in case of multiple input
    table_name = gen_subs_table(
        db=db,
        ha_min=ha_min,
        ha_max=ha_max,
        max_degree=max_degree,
        max_atoms_available=max_atoms_available,
        minimum_frequency=minimum_frequency,
        max_mass=round(max([msn_data[ms_id]["exact_mass"] for ms_id in msn_data.keys()]))
    )

    results_db.add_ms(msn_data, [ppm, ha_min, ha_max, max_atoms_available, max_degree, max_n_substructures,
                                 hydrogenation_allowance, isomeric_smiles])

    for i, ms_id in enumerate(msn_data.keys()):

        for prescribed_mass in msn_data[ms_id]["fragment_masses"]:
            fragment_smis = set()
            for j in range(0 - hydrogenation_allowance, hydrogenation_allowance + 1):
                hydrogenated_prescribed_mass = prescribed_mass + (j * 1.007825)  # consider re-arrangements

                fragment_smis.update(build(
                    mf=msn_data[ms_id]["mf"],
                    exact_mass=msn_data[ms_id]["exact_mass"],
                    max_n_substructures=max_n_substructures,
                    path_smi_out=None,
                    path_connectivity_db=path_connectivity_db,
                    path_substructure_db=path_substructure_db,
                    prescribed_mass=hydrogenated_prescribed_mass,
                    ppm=ppm,
                    out_mode=None,
                    table_name=table_name,
                    ncpus=ncpus,
                    clean=False,
                    isomeric_smiles=isomeric_smiles
                ))

            results_db.add_smis(ms_id, fragment_smis, prescribed_mass)

        results_db.calc_scores(ms_id, msn_data[ms_id]["fragment_masses"])

        if yield_smi_dict:
            yield {ms_id: results_db.structure_frequency(ms_id)}

    db.close()
    results_db.close()


def generate_structures(ms_data: Dict[str, Dict[str, Union[int, None]]],
                        path_substructure_db: Union[str, bytes, os.PathLike],
                        ha_min: Union[int, None] = 2,
                        ha_max: Union[int, None] = 9,
                        max_degree: int = 6,
                        max_atoms_available: int = 2,
                        max_n_substructures: int = 3,
                        path_smi_out: Union[str, bytes, os.PathLike, None] = None,
                        ncpus: Union[int, None] = None,
                        path_connectivity_db: Union[str, bytes, os.PathLike, None] = None,
                        minimum_frequency: Union[int, None] = None,
                        yield_smi_set: bool = True,
                        isomeric_smiles: bool = False
                        ) -> Dict[str, Sequence[list]]:
    """
    Generate molecules of a given mass using chemical substructures and connectivity graphs. Can optionally take a
    "prescribed" fragment mass to further filter results. Final structures are returned as a list and/or written in
    text format. For the generation of structures from MSn data, see
    :py:meth:`metaboblend.build_structures.annotate_msn`.

    :param ms_data: Dictionary in the form ms_data[id] =
        `{mf: [C, H, N, O, P, S], exact_mass: float, prescribed_mass=int}`. id represents a unique identifier for
        a given test, mf is a list of integers referring to molecular formula of the structure of interest,
        exact_mass is the mass of this structure to >=4d.p. and prescribed_mass is the neutral mass of a substructure
        used to limit structures generated.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param ha_min: The minimum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param ha_max: The maximum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single,
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have
        a total degree of 3.

    :param max_atoms_available: The maximum number of  atoms available of each substructure to be considered for
        building molecules. `atoms_available` refers to the number of atoms on a substructure involved in forming
        chemical bonds (e.g. single or double bonds). `atoms_available` are also limited by the extensivity of the
        supplied connectivity database.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single,
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have
        a total degree of 3.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. The max number
        of substructures is also limited by the extensivity of the supplied connectivity database.

    :param path_smi_out: The directory to which unique smile strings should be written representing the final
        structures generated. If None, no files are written.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`. If the path is None, the default connectivity
        database bundled with MetaboBlend will be used.

    :param ncpus: How many worker processes to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique. Defaults to None, in which case this filtering method is not applied.

    :param yield_smi_set: If True, yields a set of unique SMILEs string for each input molecule, else returns None.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :return: For each input molecule, yields a set of unique SMILEs strings (unless
        `yield_smi_set = False`).
    """

    db = SubstructureDb(path_substructure_db, path_connectivity_db)

    if path_connectivity_db is None:
        path_connectivity_db = os.path.join(os.path.realpath(os.path.dirname(__file__)), "data", "connectivity.sqlite")

    # prepare temporary table here - will only be generated once in case of multiple input
    table_name = gen_subs_table(
        db=db,
        ha_min=ha_min,
        ha_max=ha_max,
        max_degree=max_degree,
        max_atoms_available=max_atoms_available,
        minimum_frequency=minimum_frequency,
        max_mass=round(max([ms_data[ms_id]["exact_mass"] for ms_id in ms_data.keys()]))
    )

    for ms_id in ms_data.keys():

        ppm = None
        try:
            if ms_data[ms_id]["prescribed_masses"] is not None:
                ppm = 0
        except KeyError:
            ms_data[ms_id]["prescribed_masses"] = None

        if path_smi_out is not None:
            id_path_smi_out = os.path.join(path_smi_out, ms_id + ".smi")
        else:
            id_path_smi_out = None

        smi_set = build(
            mf=ms_data[ms_id]["mf"],
            exact_mass=ms_data[ms_id]["exact_mass"],
            max_n_substructures=max_n_substructures,
            path_smi_out=id_path_smi_out,
            path_connectivity_db=path_connectivity_db,
            path_substructure_db=path_substructure_db,
            prescribed_mass=ms_data[ms_id]["prescribed_masses"],
            ppm=ppm,
            out_mode="w",
            table_name=table_name,
            ncpus=ncpus,
            clean=False,
            isomeric_smiles=isomeric_smiles
        )

        if yield_smi_set:
            yield {ms_id: smi_set}

    db.close()


def build(mf, exact_mass, max_n_substructures, path_smi_out, path_connectivity_db, path_substructure_db,
          prescribed_mass, ppm, out_mode, ncpus, table_name, clean, isomeric_smiles):
    """
    Core function for generating molecules of a given mass using substructures and connectivity graphs. Can optionally
    take a "prescribed" fragment mass to further filter results; this can be used to incorporate MSn data. Final
    molecules are written to the specified file and/or returned in smiles format. This function represents the central
    building method used by MetaboBlend; :py:meth:`metaboblend.build_structures.generate_structures` provides a simple
    interface for generating structures of a given mass whilst
    :py:meth:`metaboblend.build_structures.annotate_msn` allows for the generation and scoring of structures using
    information from fragmentation spectra.

    :param mf: List of integers detailing the molecular formula of the target metabolite, in the format
        [C, H, N, O, P, S].

    :param exact_mass: The exact mass (float) of the target metabolite.

    :param path_smi_out: The path of the file to which unique smile strings should be written representing the final
        structures generated. If None, no file is written.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`.

    :param prescribed_mass: A mass by which to filter results; if not provided, all possible structures will be
        generated.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param out_mode: The mode in which to write to the output file.

        * **"w"** Create a new file, overwriting any existing file.

        * **"w"** Append results to an existing file.

    :param ncpus: How many CPUs to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param table_name: The table specified within the substructure database will be used to generate
        molecules. Will be removed after structures have been built, unless 'clean = False' is set.

    :param clean: Whether to remove the temporary table of substructures, table_name`, after the method is complete.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :return: Returns a set of unique SMILEs strings.
    """

    db = SubstructureDb(path_substructure_db, path_connectivity_db)
    tolerance = 0.001

    if prescribed_mass is None:
        exact_mass__1 = round(exact_mass)

    else:  # prescribed substructure build method
        if ((prescribed_mass / 1000000) * ppm) > 0.001:
            fragment_tolerance = round((prescribed_mass / 1000000) * ppm, 4)
        else:
            fragment_tolerance = 0.001

        prescribed_subset = db.select_mass_values("0_0001", [round(prescribed_mass)], table_name)
        prescribed_subset = [m for m in prescribed_subset[0] if abs(m - prescribed_mass) <= fragment_tolerance]

        if len(prescribed_subset) == 0:
            return set()

        loss = exact_mass - prescribed_mass
        exact_mass__1 = round(loss)

        if ((exact_mass / 1000000) * ppm) > 0.001:
            tolerance = round((exact_mass / 1000000) * ppm, 4)

        max_n_substructures -= 1  # we find sets of mols that add up to the loss, not the precursor mass

    if os.name == "nt":  # multiprocessing freeze support on windows
        multiprocessing.freeze_support()

    # select groups of masses at low mass resolution
    integer_mass_values = [m for m in db.select_mass_values("1", [], table_name) if m <= exact_mass__1]
    if len(integer_mass_values) == 0:
        return set()

    integer_subsets = list(subset_sum(integer_mass_values, exact_mass__1, max_n_substructures))

    configs_iso = db.k_configs()
    if path_smi_out is not None:
        smi_out = open(path_smi_out, out_mode)

    substructure_subsets = []
    for integer_subset in integer_subsets:
        if len(integer_subset) > max_n_substructures or len(integer_subset) == 0:
            continue

        # refine groups of masses to 4dp mass resolution
        exact_mass_values = db.select_mass_values("0_0001", integer_subset, table_name)

        if prescribed_mass is not None:
            exact_mass_values = [prescribed_subset] + exact_mass_values

        # use combinations to get second group of masses instead of subset sum - subset sum is integer mass only
        exact_subsets = []
        for mass_combo in itertools.product(*exact_mass_values):
            if abs(sum(mass_combo) - exact_mass) <= tolerance:
                exact_subsets.append(mass_combo)

        if len(exact_subsets) == 0:
            continue

        # refines groups based on ecs and gets substructures from db (appends to substructure_subsets)
        for exact_subset in exact_subsets:
            substructure_subsets += build_from_subsets(exact_subset, mf=mf, table_name=table_name, db=db)

    with multiprocessing.Pool(processes=ncpus) as pool:  # send sets of substructures for building
        smi_lists = pool.map(
            partial(substructure_combination_build, configs_iso=configs_iso,
                    prescribed_structure=prescribed_mass, isomeric_smiles=isomeric_smiles),
            substructure_subsets
        )

    smis = set([val for sublist in smi_lists for val in sublist])

    if path_smi_out is not None:
        if len(smis) != 0:
            smi_out.writelines("\n".join(smis))

        smi_out.close()

    db.close(clean)

    return smis


def gen_subs_table(db, ha_min, ha_max, max_degree, max_atoms_available, max_mass, table_name="subset_substructures",
                   minimum_frequency=None):
    """
    Generate a temporary secondary substructure table restricted by a set of parameters. Generated as an initial step
    in :py:meth:`metaboblend.build_structures.generate_structures` and
    :py:meth:`metaboblend.build_structures.annotate_msn` in order to limit the processing overhead as a result of
    repeatedly querying the SQLite substructure database.

    :param max_mass: The maximum allowed mass of substructures in the temporary table; there is no point considering
        substructures with greater mass than the target mol.

    :param db: Connection to a :py:meth:`metaboblend.databases.SubstructureDb` from which to extract substructures.

    :param ha_min: Minimum value of `heavy_atoms` for substructures to be transferred into the temporary table.
        If None, no limit is applied.

    :param ha_max: Maximum value of `heavy_atoms` for substructures to be transferred into the temporary table.
        If None, no limit is applied.

    :param max_degree: The maximum total valence (ie, the product of `atoms_available` and the degree of their bonds)
        to be included in the temporary table.

    :param max_atoms_available: The maximal atoms available of substructures to be included in the temporary table.

    :param table_name: Defaults to "subset_substructures", which is cleaned up upon database closure. The name of the
        table to be generated

    :return: The name of the temporary secondary substructure table.

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique.
    """

    db.cursor.execute("DROP TABLE IF EXISTS %s" % table_name)

    if minimum_frequency is None:
        freq_statement = ""
    else:
        freq_statement = """
                            AND smiles IN 
                                (SELECT smiles 
                                    FROM hmdbid_substructures 
                                    GROUP BY smiles 
                                    HAVING COUNT(*) >= {})
                         """.format(minimum_frequency,)

    if ha_min is None:
        ha_min_statement = ""
    else:
        ha_min_statement = """
                              AND heavy_atoms >= %s""" % str(ha_min)

    if ha_max is None:
        ha_max_statement = ""
    else:
        ha_max_statement = """
                              AND heavy_atoms <= %s""" % str(ha_max)

    db.cursor.execute("""CREATE TABLE {} AS
                             SELECT * FROM substructures WHERE
                                 atoms_available <= {} AND
                                 valence <= {} AND
                                 exact_mass__1 < {}{}{}{}
                      """.format(table_name,
                                 max_atoms_available,
                                 max_degree,
                                 max_mass,
                                 freq_statement,
                                 ha_min_statement,
                                 ha_max_statement))

    db.create_indexes(table=table_name, selection="gen_subs_table")

    return table_name


def build_from_subsets(exact_subset, mf, table_name, db):
    """
    A stage of the :py:meth:`metaboblend.build_structures.build` workflow for generating molecules to a given mass
    from substructures. At this stage, mass subsets have been identified in the substructure database. Each of these
    groups are now filtered further by identifying masses that refer to valid subsets of molecules, before they are
    built to generate new molecules.

    :param db: The substructure and connectivity database. Elemental compositions and substructures are retrieved from
        the database; this information is listed as "substructure_subset" and will be appended to the
        substructure_subsets list provided as a parameter.

    :param exact_subset: Group of masses that sum to the correct total mass, refer to substructures in the substructure
        database.

    :param mf: List of integers detailing the molecular composition of the target metabolite, in the format
        `[C, H, N, O, P, S]`.

    :param table_name: The name of the table within the substructure database from which to extract substructures. A
        prefiltered table based on the parameters specified in :py:meth:`metaboblend.build_structures.build`. See
        :py:meth:`metaboblend.build_structures.gen_subs_table`.
    """

    substructure_subsets = []

    mf_subset = combine_mfs(exact_subset, db, table_name, "0_0001")

    if len(mf_subset) == 0:
        return []

    for ec_product in itertools.product(*mf_subset):

        if mf != list(numpy.array(ec_product).sum(axis=0)):
            continue  # check each set of elemental compositions matches the target mol

        substructure_subset = db.select_substructures(ec_product, table_name)

        if len(substructure_subset) == 0:
            continue

        substructure_subsets.append(substructure_subset)

    return substructure_subsets


def substructure_combination_build(substructure_subset, configs_iso, prescribed_structure, isomeric_smiles):
    """
    Final stage for building molecules; takes a combination of substructures (substructure_combination) and builds them
    according to graphs in the substructure database. May be run in parallel.

    :param substructure_subset: Combinations of substructures for building mols.

    :param configs_iso: Possible substructure combinations extracted from the connectivity database. A tuple containing
        tuples for each substructure; these tuples specify how many bonds each substructure can make.

    :return: List of smiles representing molecules generated (and the substructures used to generate them).
    """

    smis = []

    for substructure_combination in itertools.product(*substructure_subset):
        substructure_combination[0]["fragment"] = True
        substructure_combination = sorted(substructure_combination, key=itemgetter('atoms_available', 'valence'))

        v_a = ()
        if prescribed_structure is not None:
            fragment_indexes = []
        j = -1
        for i, d in enumerate(substructure_combination):
            v_a += (tuple(d["degree_atoms"].values()),)  # obtain valence configuration of the set of substructures

            for atom_available in tuple(d["degree_atoms"].values()):
                j += 1

                try:
                    if prescribed_structure is not None and d["fragment"]:
                        fragment_indexes.append(j)
                except KeyError:
                    continue

        if str(v_a) not in configs_iso:  # check mols "fit" together according to the connectivity database
            continue

        mol_comb, atoms_available, atoms_to_remove, bond_types, bond_mismatch = reindex_atoms(substructure_combination)

        if bond_mismatch:
            continue  # check that bond types are compatible (imperfect check)

        for edges in configs_iso[str(v_a)]:  # build mols for each graph in connectivity db
            if prescribed_structure is not None:
                non_fragment_edges = False

                for edge in edges:  # check that edges only connect to fragment ion
                    if edge[0] not in fragment_indexes and edge[1] not in fragment_indexes:
                        non_fragment_edges = True

                if non_fragment_edges:
                    continue

            mol_e = add_bonds(mol_comb, edges, atoms_available, bond_types)  # add bonds between substructures

            if mol_e is None:
                continue

            atoms_to_remove.sort(reverse=True)
            [mol_e.RemoveAtom(a) for a in atoms_to_remove]  # clean up dummy atoms

            mol_out = mol_e.GetMol()  # generate the final (non-editable) mol

            try:
                Chem.SanitizeMol(mol_out)  # clean the mol - ensure it is valid & canonical
            except:
                continue

            try:  # append the canonical smiles of the final structure
                smis.append(Chem.MolToSmiles(mol_out, isomericSmiles=isomeric_smiles))
            except RuntimeError:
                continue  # bad bond type violation

    return smis
