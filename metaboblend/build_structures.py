#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright Â© 2019-2020 Ralf Weber
#
# This file is part of MetaboBlend.
#
# MetaboBlend is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MetaboBlend is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MetaboBlend.  If not, see <https://www.gnu.org/licenses/>.
#

import os
import copy
import numpy
import itertools
import multiprocessing
import networkx as nx
from functools import partial
from operator import itemgetter
from typing import Sequence, Dict, Union

from rdkit import Chem

from .results import ResultsDb
from .parse import parse_ms_data
from .algorithms import subset_sum
from .databases import SubstructureDb


def combine_mfs(precise_mass_grp, db, table_name, accuracy):
    """
    A wrapper for :py:meth:`metaboblend.databases.select_ecs` that instead takes a group of subsets, as generated by
    the second stage of :py:meth:`metaboblend.build_structures.subset_sum` in
    :py:meth:`metaboblend.build_structures.build`.

    :param precise_mass_grp: A list containing the masses of substructures identified by subset_sum.

    :param db: The :py:meth:`metaboblend.databases.SubstructureDb` in which to search for elemental compositions.

    :param table_name: The name of the table containing substructures in which to search for elemental compositions.

    :param accuracy: To which decimal places of accuracy results are to be limited to.

            * **1** Integer level
            * **0_0001** Four decimal places

    :return: If there are no elemental compositions for any of the masses in the group, then an empty list is returned.
    """

    ecs = []

    for i in range(len(precise_mass_grp)):
        atoms = db.select_mfs(precise_mass_grp[i], table_name, accuracy)

        if len(atoms) == 0:
            return []

        ecs.append(atoms)

    return ecs


def reindex_atoms(records):
    """
    Parses the libs of groups of substructures that are to be combined; the lib is a dictionary containing details
    about the substructure, as generated by :py:meth:`metaboblend.databases.get_substructure`. Combines the
    molecules into a single :py:meth:`rdkit.Chem.Mol` object and obtains details on their bonding properties.

    :param records: Takes a list of lib dictionaries that contain details on each substructure to be combined.

    :return: Returns a tuple containing a :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule, followed by information on the substructure bonding properties, including:

        * **atoms_available** A list of the indices of atoms that are available for bonding.

        * **atoms_to_remove** A list of the indices of dummy atoms that are to be removed in order to bond with other
        substructures.

        * **bond_types** A dictionary containing the indices of atoms that are available for bonding as keys and values
        detailing their bond types. See :py:meth:`metaboblend.build_structures.add_bonds`.
    """

    atoms_available, atoms_to_remove, bond_types = [], [], {}
    mol_comb = Chem.Mol()
    index_atoms, all_bond_types = [], {}
    c = 0

    for i, record in enumerate(records):
        idxs = []
        all_bond_types[i] = []
        for atom in record["mol"].GetAtoms():

            new_idx = atom.GetIdx() + c
            idxs.append(new_idx)

            if atom.GetIdx() in record["degree_atoms"]:
                atoms_available.append(new_idx)

            if atom.GetIdx() in record["dummies"]:
                atoms_to_remove.append(new_idx)

            if atom.GetIdx() in record["bond_types"]:
                bond_types[new_idx] = record["bond_types"][atom.GetIdx()]
                all_bond_types[i] += record["bond_types"][atom.GetIdx()]

        mol_comb = Chem.CombineMols(mol_comb, record["mol"])
        index_atoms.append(idxs)
        c = idxs[-1] + 1

    # check that bond types add up - removes some mismatched configurations
    bond_mismatch = False
    for i in range(len(records)):
        other_bonds = []
        for j in range(len(records)):
            if i != j:
                other_bonds += all_bond_types[j]

        for bond in all_bond_types[i]:
            if bond not in other_bonds:
                bond_mismatch = True

    return mol_comb, atoms_available, atoms_to_remove, bond_types, bond_mismatch


def add_bonds(mols, edges, atoms_available, bond_types, bond_enthalpies):
    """
    Takes a set of substructures and attempts to combine them together to generate a final structure. One of the last
    steps in the :py:meth:`metaboblend.build_structures.build` workflow.

    :param mols: A :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule.

    :param edges: The edges to use in order to join the substructures together, obtained from the connectivity database
        (:py:meth:`metaboblend.databases.create_isomorphism_database`).

    :param atoms_available: A list of the indices of atoms that are available for bonding.

    :param bond_types:  The type of bonds to be formed by dummy atoms - see :py:meth:`Chem.rdchem.BondType`. Is a
        dictionary whose keys are atom indices and values are bond types, as follows:

            * **1.0** Single

            * **1.5** Aromatic

            * **2.0** Double

    :param bond_enthalpies: Dictionary of bond enthalpies, as generated by
    :py:meth:`metaboblend.build_structures.get_bond_enthalpies`.

    :return: If unsuccessful, returns None, else returns an :py:meth:`rdkit.Chem.EditableMol` object containing
        the substructures combined into a final single molecule.
    """

    rdkit_bond_types = {1: Chem.rdchem.BondType.SINGLE,
                        1.5: Chem.rdchem.BondType.AROMATIC,
                        2: Chem.rdchem.BondType.DOUBLE}

    bond_types_copy = copy.deepcopy(bond_types)  # deep copy as we modify items within the dict

    g = nx.Graph()
    g.add_edges_from(edges)

    g = nx.relabel_nodes(g, dict(zip(sorted(g.nodes()), atoms_available)))

    total_bde = 0

    mol_edit = Chem.EditableMol(mols)
    for edge in g.edges():

        if edge[0] in bond_types_copy:
            bt_start = bond_types_copy[edge[0]]
        else:
            return None, None  # nested dummy

        if edge[1] in bond_types_copy:
            bt_end = bond_types_copy[edge[1]]
        else:
            return None, None  # nested dummy

        bond_matches = list(set(bt_start).intersection(bt_end))

        if len(bond_matches) == 0:
            return None, None

        else:
            bt_start.remove(bond_matches[0])
            bt_end.remove(bond_matches[0])

        try:  # try forming the specified bond
            mol_edit.AddBond(edge[0], edge[1], rdkit_bond_types[bond_matches[0]])
        except KeyError:
            return None, None  # unknown bond type

        # calculate bond dissociation energy of "formed" bonds for the structure
        try:
            total_bde += bond_enthalpies[bond_matches[0]][mols.GetAtomWithIdx(edge[0]).GetSymbol()][mols.GetAtomWithIdx(edge[1]).GetSymbol()]
        except (SyntaxError, TypeError):
            total_bde = None

    return mol_edit, total_bde


def annotate_msn(msn_data: Union[str, os.PathLike, Dict[str, Dict[str, Union[int, list]]]],
                 path_substructure_db: Union[str, bytes, os.PathLike] = os.path.realpath(os.getcwd()),
                 path_out: Union[str, bytes, os.PathLike] = "",
                 ppm: int = 5,
                 ha_min: Union[int, None] = None,
                 ha_max: Union[int, None] = None,
                 max_atoms_available: int = 2,
                 max_degree: int = 6,
                 max_n_substructures: int = 3,
                 path_connectivity_db: Union[str, bytes, os.PathLike, None] = None,
                 ncpus: Union[int, None] = None,
                 minimum_frequency: Union[int, None] = None,
                 hydrogenation_allowance: int = 2,
                 yield_smis: bool = True,
                 isomeric_smiles: bool = False,
                 write_csv_output: bool = True,
                 retain_substructures: bool = False,
                 abs_error: float = 0.0001
                 ) -> Dict[str, Sequence[Dict[str, int]]]:
    """
    Generate molecules of a given mass using chemical substructures, connectivity graphs and spectral trees or
    fragmentation spectra. Final structures and rankings are yielded by the function as a dictionary and/or written in
    text format. For the generation of structures without MSn data, see
    :py:meth:`metaboblend.build_structures.generate_structures`.

    :param msn_data: Either a dictionary or the path to an MSP file. MSP files are parsed by
        :py:meth:`metaboblend.parse.parse_ms_data` before being converted into a dictionary. If a dictionary is
        provided, it must contain one item per fragmentation spectrum; the keys of the dictionary should be a unique ID
        for the query and the corresponding value must itself be a dictionary, containing the following:

        - "exact_mass": `float` (neutral mass of query) OR "precursor_mz": `float` (mz of precursor ion)
        - "mf": `[C, H, N, O, P, S]` (a list of 6 integers)
        - "neutral_fragment_masses": `[float, float, ...]` (list of neutral fragment masses) OR "fragment_mzs":
            `[float, float, ...]` (list of fragment mzs)
        - "precursor_type": `str` (e.g. "[M+H]+", required for calculating neutral masses from ion mzs)

        The dictionary or MSP path is fed to :py:meth:`metaboverse.parse.parse_ms_data`.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param path_out: Folder to which the SQLite 3 results database and CSV outputs should be written.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param ha_min: The minimum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param ha_max: The maximum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param max_atoms_available: The maximum number of  atoms available of each substructure to be considered for
        building molecules. `atoms_available` refers to the number of atoms on a substructure involved in forming
        chemical bonds (e.g. single or double bonds). `atoms_available` are also limited by the extensivity of the
        supplied connectivity database.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single, 
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For 
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have 
        a total degree of 3.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. The max number
        of substructures is also limited by the extensivity of the supplied connectivity database.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`. If the path is None, the default connectivity
        database bundled with MetaboBlend will be used.

    :param ncpus: How many CPUs to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique. Defaults to None, in which case this filtering method is not applied.

    :param hydrogenation_allowance: In order to represent re-arrangement events (the movement of hydrogens), in
        addition to attempting to build from substructures in prescribed_masses, we also attempt to build from
        `fragment_masses +- hydrogenation_allowance`. E.g. if `prescribed_masses = [141.5938]` and
        `hydrogenation_allowance = 1` then, to find candidate fragment substructures, we use as query the masses
        `[141.5938 - 1.007825, 141.5938, 141.5938 + 1.007825]`.

    :param yield_smis: If True, for each input molecule the function yields SMILEs the number of `fragment_masses` by
        which the structure was generated. Else, returns None.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :param write_csv_output: Whether to extract results from the SQLite3 database for deposition in CSV files.

    :param retain_substructures: Whether to record the substructures used to generate final structures.

    :param abs_error: Allowable absolute mz deviation from MS peaks.

    :return: For each input molecule yields a dictionary whose keys are SMILEs strings for the generated
        structures and values are the number of `fragment_masses` by which the structure was built (unless
        `yield_smi_dict = False`).
    """

    if ppm is None:
        ppm = 0

    if path_connectivity_db is None:
        path_connectivity_db = os.path.join(os.path.realpath(os.path.dirname(__file__)), "data", "connectivity.sqlite")

    db = SubstructureDb(path_substructure_db, path_connectivity_db)
    results_db = ResultsDb(path_out)
    results_db.create_results_db()

    # prepare temporary table here - will only be generated once in case of multiple input
    table_name = gen_subs_table(
        db=db,
        ha_min=ha_min,
        ha_max=ha_max,
        max_degree=max_degree,
        max_atoms_available=max_atoms_available,
        minimum_frequency=minimum_frequency,
        max_mass=None
    )

    for i, ms in enumerate(parse_ms_data(msn_data)):
        
        if ms is None:
            continue

        results_db.add_ms(msn_data, ms["ms_id"], i, [ppm, ha_min, ha_max, max_atoms_available, max_degree,
                                                     max_n_substructures, hydrogenation_allowance, isomeric_smiles])

        for j, fragment_mass in enumerate(ms["neutral_fragment_masses"]):

            # start off by getting the substructures that could represent the fragment ion
            possible_fragment_ions = get_possible_fragment_ions(fragment_mass, db, hydrogenation_allowance, ppm, 0.001, table_name)

            smi_dict = build(
                db=db,
                mf=ms["mf"],
                exact_mass=ms["exact_mass"],
                max_n_substructures=max_n_substructures,
                prescribed_substructures=possible_fragment_ions,
                ppm=ppm,
                table_name=table_name,
                ncpus=ncpus,
                isomeric_smiles=isomeric_smiles,
                retain_substructures=retain_substructures,
                tolerance=abs_error
            )

            results_db.add_results(i, smi_dict, fragment_mass, j, retain_substructures)
            smi_dict = None

        results_db.calculate_scores(i)

        if yield_smis:
            yield {ms["ms_id"]: results_db.get_structures(i)}

    if write_csv_output:
        results_db.generate_csv_output()

    db.close()
    results_db.close()


def generate_structures(ms_data: Union[str, os.PathLike, Dict[str, Dict[str, Union[int, None]]]],
                        path_substructure_db: Union[str, bytes, os.PathLike],
                        path_out: Union[str, bytes, os.PathLike] = os.path.realpath(os.getcwd()),
                        ha_min: Union[int, None] = 2,
                        ha_max: Union[int, None] = 9,
                        max_degree: int = 6,
                        max_atoms_available: int = 2,
                        max_n_substructures: int = 3,
                        ncpus: Union[int, None] = None,
                        path_connectivity_db: Union[str, bytes, os.PathLike, None] = None,
                        minimum_frequency: Union[int, None] = None,
                        yield_smis: bool = True,
                        isomeric_smiles: bool = False,
                        write_csv_output: bool = True,
                        retain_substructures: bool = False
                        ) -> Dict[str, Sequence[set]]:
    """
    Generate molecules of a given mass using chemical substructures and connectivity graphs. Can optionally take a
    "prescribed" fragment mass to further filter results. Final structures are returned as a list and/or written in
    text format. For the generation of structures from MSn data, see
    :py:meth:`metaboblend.build_structures.annotate_msn`.

    :param ms_data: A dictionary that must contain one item per fragmentation spectrum; the keys of the dictionary
        should be a unique ID for the query and the corresponding value must itself be a dictionary, containing the
        following:

        - "exact_mass": `float` (neutral mass of query) OR "precursor_mz": `float` (mz of precursor ion)
        - "mf": `[C, H, N, O, P, S]` (a list of 6 integers)
        - "precursor_type": `str` (e.g. "[M+H]+", required for calculating neutral masses from ion mzs)
        - (optional) "prescribed_mass": 'float' (neutral mass of substructure).

        The dictionary or MSP path is fed to :py:meth:`metaboverse.parse.parse_ms_data`. A single neutral substructure
        mass may be provided ("prescribed_mass") to guide the structure generation process.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param path_out: Folder to which the SQLite 3 results database and CSV outputs should be written.

    :param ha_min: The minimum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param ha_max: The maximum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single,
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have
        a total degree of 3.

    :param max_atoms_available: The maximum number of  atoms available of each substructure to be considered for
        building molecules. `atoms_available` refers to the number of atoms on a substructure involved in forming
        chemical bonds (e.g. single or double bonds). `atoms_available` are also limited by the extensivity of the
        supplied connectivity database.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single,
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have
        a total degree of 3.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. The max number
        of substructures is also limited by the extensivity of the supplied connectivity database.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`. If the path is None, the default connectivity
        database bundled with MetaboBlend will be used.

    :param ncpus: How many worker processes to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique. Defaults to None, in which case this filtering method is not applied.

    :param yield_smis: If True, yields a set of unique SMILEs string for each input molecule, else returns None.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :param write_csv_output: Whether to extract results from the SQLite3 database for deposition in CSV files.

    :param retain_substructures: Whether to record the substructures used to generate final structures.

    :return: For each input molecule, yields unique SMILEs strings (unless `yield_smis = False`).
    """

    if path_connectivity_db is None:
        path_connectivity_db = os.path.join(os.path.realpath(os.path.dirname(__file__)), "data", "connectivity.sqlite")

    db = SubstructureDb(path_substructure_db, path_connectivity_db)

    results_db = ResultsDb(path_out, False)
    results_db.create_results_db()

    # prepare temporary table here - will only be generated once in case of multiple input
    table_name = gen_subs_table(
        db=db,
        ha_min=ha_min,
        ha_max=ha_max,
        max_degree=max_degree,
        max_atoms_available=max_atoms_available,
        minimum_frequency=minimum_frequency,
        max_mass=round(max([ms_data[ms_id]["exact_mass"] for ms_id in ms_data.keys()]))
    )

    for i, ms in enumerate(parse_ms_data(ms_data, False)):

        results_db.add_ms(ms_data, ms["ms_id"], i, [None, ha_min, ha_max, max_atoms_available, max_degree, max_n_substructures, None, isomeric_smiles])

        ppm = None
        prescribed_substructures = None

        try:
            if ms["prescribed_mass"] is not None:
                ppm = 0
                prescribed_substructures = get_possible_fragment_ions(ms["prescribed_mass"], db, table_name=table_name)

        except KeyError:
            ms["prescribed_mass"] = None

        smi_dict = build(
            mf=ms["mf"],
            exact_mass=ms["exact_mass"],
            max_n_substructures=max_n_substructures,
            prescribed_substructures=prescribed_substructures,
            ppm=ppm,
            table_name=table_name,
            ncpus=ncpus,
            isomeric_smiles=isomeric_smiles,
            retain_substructures=retain_substructures,
            db=db,
            tolerance=0.0001
        )

        results_db.add_results(i, smi_dict, ms["prescribed_mass"])
        smi_dict = None

        results_db.calculate_scores(i)

        if yield_smis:
            yield {ms["ms_id"]: results_db.get_structures(i)}

    if write_csv_output:
        results_db.generate_csv_output()

    db.close()


def get_possible_fragment_ions(neutral_fragment_mass, db, hydrogenation_allowance=None, ppm=None, tolerance=None, table_name=None):
    """
    Get possible fragment ions from a neutral mass. Either matches the mass exactly or does approximate matching
    (within the allowable absolute or relative tolerance).

    :param neutral_fragment_mass: The neutral mass of the MS fragment.

    :param hydrogenation_allowance: Searches for substructures within `+-hydrogenation_allowance` hydrogen masses for
        substructures. Substructures that are matched by the neutral fragment mass itself are considered "even" whereas
        those matched by the modified masses are considered "odd" (i.e. non-standard hydrogen re-arrangements). In the
        case of exact find, this field is left as None.

    :param db: Connection to the SQLite3 substructure database, :py:meth:`metaboblend.databases.SubstructureDb`.

    :param ppm: The relative (parts per million) tolerance for the neutral fragment mass. In the case of exact find,
        this field is ignored.

    :param tolerance: The minimum absolute mz tolerance for the neutral fragment mass. In the case of exact find, this
        field is ignored.

    :param table_name: Name of the substructures and substructure_ions tables to query. If None, uses the main tables.

    :return: A dictionary in the format:
        {integer_mass (int): {exact_mass (float): {substructure_id (int): substructure (dict)}}}.
    """

    if table_name is None:
        subs_table_name = "substructures"
        subs_ions_table_name = "substructure_ions"
    else:
        subs_table_name = table_name + "_substructures"
        subs_ions_table_name = table_name + "_substructure_ions"

    fragments = {}

    if hydrogenation_allowance is None:  # exact find

        exact_mass__1 = round(neutral_fragment_mass, 0)
        exact_mass_0_0001 = round(neutral_fragment_mass, 4)

        fragments[exact_mass__1] = {exact_mass_0_0001: {}}

        db.cursor.execute("""SELECT smiles, mol, bond_types, valence_atoms, valence, atoms_available, dummies, 
                                    C, H, N, O, P, S, substructure_id
                                 FROM {}
                                 WHERE exact_mass__0_0001 = {}
                          """.format(subs_table_name, exact_mass_0_0001))

        for record in db.cursor.fetchall():

            substructure = {
                "smiles": record[0],
                "mol": Chem.Mol(record[1]),
                "bond_types": eval(record[2]),
                "degree_atoms": eval(record[3]),
                "valence": record[4],
                "atoms_available": record[5],
                "dummies": eval(record[6]),
                "even": True,
                "mf": (record[7], record[8], record[9], record[10], record[11], record[12],)
            }

            fragments[exact_mass__1][exact_mass_0_0001][record[13]] = substructure

    else:  # approximate find +- hydrogens

        for i in range(0 - hydrogenation_allowance, hydrogenation_allowance + 1):

            hydrogenated_fragment_mass = neutral_fragment_mass + (i * 1.007825)  # consider non-standard re-arrangements

            if ((hydrogenated_fragment_mass / 1000000) * ppm) > tolerance:
                fragment_tolerance = round((hydrogenated_fragment_mass / 1000000) * ppm, 4)
            else:
                fragment_tolerance = tolerance

            db.cursor.execute("""SELECT smiles, mol, bond_types, valence_atoms, valence, atoms_available, dummies,
                                        exact_mass__0_0001, exact_mass__1, C, H, N, O, P, S, substructure_id
                                     FROM {}
                                     WHERE substructure_id IN (
                                         SELECT substructure_id
                                             FROM {}
                                             WHERE modified_exact_mass__0_0001 > {} and modified_exact_mass__0_0001 < {})
                              """.format(
                                     subs_table_name,
                                     subs_ions_table_name,
                                     hydrogenated_fragment_mass - fragment_tolerance,
                                     hydrogenated_fragment_mass + fragment_tolerance
                                 ))

            for record in db.cursor.fetchall():

                substructure = {
                    "smiles": record[0],
                    "mol": Chem.Mol(record[1]),
                    "bond_types": eval(record[2]),
                    "degree_atoms": eval(record[3]),
                    "valence": record[4],
                    "atoms_available": record[5],
                    "dummies": eval(record[6]),
                    "even": i == 0,
                    "mf": (record[9], record[10], record[11], record[12], record[13], record[14],)
                }

                if record[8] not in fragments.keys():
                    fragments[record[8]] = {record[7]: {record[15]: substructure}}

                elif record[7] not in fragments[record[8]].keys():
                    fragments[record[8]][record[7]] = {record[15]: substructure}

                # if hydrogenation modifications have been made (i.e. i != 0) do not modify existing record
                elif record[15] not in fragments[record[8]][record[7]].keys() or i == 0:
                    fragments[record[8]][record[7]][record[15]] = substructure

    return fragments


def build(db, mf, exact_mass, max_n_substructures, prescribed_substructures, ppm, ncpus, table_name, isomeric_smiles,
          retain_substructures, tolerance):
    """
    Core function for generating molecules of a given mass using substructures and connectivity graphs. Can optionally
    take a "prescribed" fragment mass to further filter results; this can be used to incorporate MSn data. Final
    molecules are written to the specified file and/or returned in smiles format. This function represents the central
    building method used by MetaboBlend; :py:meth:`metaboblend.build_structures.generate_structures` provides a simple
    interface for generating structures of a given mass whilst
    :py:meth:`metaboblend.build_structures.annotate_msn` allows for the generation and scoring of structures using
    information from fragmentation spectra.

    :param db: Connection to the SQLite3 substructure database, :py:meth:`metaboblend.databases.SubstructureDb`.

    :param mf: List of integers detailing the molecular formula of the target metabolite, in the format
        [C, H, N, O, P, S].

    :param exact_mass: The exact mass (float) of the target metabolite.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules.

    :param prescribed_substructures: Substructures by which to filter results, as generated by
        :py:meth:`metaboblend.build_structures.get_possible_fragment_ions`.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param ncpus: How many CPUs to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param table_name: The table specified within the substructure database will be used to generate
        molecules. Will be removed after structures have been built, unless 'clean = False' is set.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :param retain_substructures: Whether to record the substructures used to generate final structures.

    :param tolerance: Minimum absolute mz tolerance for the fragment and precursor masses. Only used if
        `prescribed_substructures` is not None.

    :return: Returns a set of unique SMILEs strings.
    """

    configs_iso = db.k_configs()

    # select groups of masses at low mass resolution
    integer_mass_values = [m for m in db.select_mass_values("1", [], table_name) if m <= round(exact_mass, 0)]

    if os.name == "nt":  # multiprocessing freeze support on windows
        multiprocessing.freeze_support()

    substructure_subsets = []

    if prescribed_substructures is None:  # standard build method, does not require knowledge of a substructure of the target metabolite
        substructure_subsets = refine_masses_standard(substructure_subsets, mf, exact_mass, integer_mass_values, max_n_substructures, table_name, db)

    else:  # MSn build method - requires a list of possible substructures (prescribed_substructures)

        substructure_subsets = refine_masses_prescribed(substructure_subsets, mf, exact_mass, prescribed_substructures, ppm, integer_mass_values, max_n_substructures - 1, table_name, db, tolerance)

    with multiprocessing.Pool(processes=ncpus) as pool:  # send sets of substructures for building
        smi_dicts = pool.map(
            partial(substructure_combination_build, configs_iso=configs_iso,
                    prescribed_method=prescribed_substructures is not None, isomeric_smiles=isomeric_smiles,
                    bond_enthalpies=get_bond_enthalpies(), retain_substructures=retain_substructures),
            substructure_subsets
        )

    smi_dict = {}
    for d in smi_dicts:
        for k in d.keys():
            try:
                smi_dict[k]["bdes"] += d[k]["bdes"]

                if retain_substructures:
                    smi_dict[k]["substructures"] += d[k]["substructures"]

            except KeyError:
                smi_dict[k] = d[k]

    return smi_dict


def refine_masses_standard(substructure_subsets, mf, exact_mass, integer_mass_values, max_n_substructures, table_name,
                           db):
    """
    Takes a set of masses and applies :py:meth:`metaboblend.algorithms.subset_sum`. Generates a list of subsets of
    substructures to be combined into candidate target metabolites.

    :param substructure_subsets: List of substructure subsets to be filled, usually empty.

    :param integer_mass_values: List of possible integer masses for all valid substructures.

    :param max_n_substructures: The maximum number of substructures to be combined.

    :param table_name: The name of the table from which to extract substructures - if None, searches the main tables.

    :param db: Connection to the SQLite3 substructure database, :py:meth:`metaboblend.databases.SubstructureDb`.

    :param mf: List of integers detailing the molecular formula of the target metabolite, in the format
        [C, H, N, O, P, S].

    :param exact_mass: The exact mass (float) of the target metabolite.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules.

    :return: Returns a list of lists - one list for each substructure subset. Each substructure subset list contains
        a list for each
    """

    integer_subsets = list(subset_sum(integer_mass_values, int(round(exact_mass, 0)), max_n_substructures))

    for integer_subset in integer_subsets:

        if len(integer_subset) > max_n_substructures or len(integer_subset) == 0:
            continue

        # refine groups of masses to 4dp mass resolution
        exact_mass_values = db.select_mass_values("0_0001", integer_subset, table_name)

        # use combinations to get second group of masses instead of subset sum - subset sum is integer mass only
        exact_subsets = []
        for mass_combo in itertools.product(*exact_mass_values):
            if round(sum(mass_combo), 4) == round(exact_mass, 4):
                exact_subsets.append(mass_combo)

        if len(exact_subsets) == 0:
            continue

        # refines groups based on ecs and gets substructures from db (appends to substructure_subsets)
        for exact_subset in exact_subsets:
            substructure_subsets += build_from_subsets(exact_subset, mf=mf, table_name=table_name, db=db)

    return substructure_subsets


def refine_masses_prescribed(substructure_subsets, mf, exact_mass, prescribed_substructures, ppm, integer_mass_values,
                             max_n_substructures, table_name, db, tolerance):
    """
    Takes a set of masses and applies :py:meth:`metaboblend.algorithms.subset_sum`. Generates a list of subsets of
    substructures to be combined with possible fragment substructures to generate candidate target metabolites.

    :param prescribed_substructures: Substructures that may represent the neutral fragment structure, as retrieved
        by :py:meth:`metaboblend.build_structures.get_possible_fragment_ions`.

    :param substructure_subsets: List of substructure subsets to be filled, usually empty.

    :param integer_mass_values: List of possible integer masses for all valid substructures.

    :param max_n_substructures: The maximum number of substructures to be combined.

    :param table_name: The name of the table from which to extract substructures - if None, searches the main tables.

    :param db: Connection to the SQLite3 substructure database, :py:meth:`metaboblend.databases.SubstructureDb`.

    :param mf: List of integers detailing the molecular formula of the target metabolite, in the format
        [C, H, N, O, P, S].

    :param exact_mass: The exact mass (float) of the target metabolite.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. Note that this
        does not include the fragment substructure itself.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param tolerance: Minimum absolute mz tolerance for the fragment and precursor masses. Only used if
        `prescribed_substructures` is not None.

    :return: Returns a list of lists - one list for each substructure subset. Each substructure subset list contains
        a list for each
    """

    # for each fragment peak in the MS2 spectrum
    for fragment_mass__1 in prescribed_substructures.keys():

        # work out the corresponding neutral loss
        loss_mass__1 = int(round(round(exact_mass, 0) - fragment_mass__1, 0))

        if ((exact_mass / 1000000) * ppm) > tolerance:
            tolerance = round((exact_mass / 1000000) * ppm, 4)

        if len(integer_mass_values) == 0:
            return {}

        # get subsets of masses at integer level that could build up to the loss mass (i.e. can be combined with fragment substructure(s))
        integer_subsets = list(subset_sum(integer_mass_values, loss_mass__1, max_n_substructures))

        for integer_subset in integer_subsets:

            if len(integer_subset) > max_n_substructures or len(integer_subset) == 0:
                continue

            # refine groups of (loss) masses to 4dp mass resolution
            exact_mass_values = db.select_mass_values("0_0001", integer_subset, table_name)

            for fragment_mass_0_0001 in prescribed_substructures[fragment_mass__1].keys():

                # use combinations to get second group of masses instead of subset sum - subset sum is integer mass only
                exact_subsets = []
                for mass_combo in itertools.product(*exact_mass_values):
                    if abs((fragment_mass_0_0001 + sum(mass_combo)) - exact_mass) <= tolerance:
                        exact_subsets.append(mass_combo)

                if len(exact_subsets) == 0:
                    continue

                # refines groups based on ecs and gets substructures from db (appends to substructure_subsets)
                mf_to_substructure_id = {}
                for substructure_id in prescribed_substructures[fragment_mass__1][fragment_mass_0_0001].keys():
                    try:
                        mf_to_substructure_id[tuple(prescribed_substructures[fragment_mass__1][fragment_mass_0_0001][substructure_id]["mf"])].append(substructure_id)
                    except KeyError:
                        mf_to_substructure_id[tuple(prescribed_substructures[fragment_mass__1][fragment_mass_0_0001][substructure_id]["mf"])] = [substructure_id]

                for fragment_mf in mf_to_substructure_id.keys():
                    for exact_subset in exact_subsets:

                        loss_mf = [atom - fragment_atom for atom, fragment_atom in zip(mf, fragment_mf)]

                        substructure_subsets += build_from_subsets(
                            exact_subset,
                            mf=loss_mf,
                            table_name=table_name,
                            db=db,
                            fragment_substructures=[prescribed_substructures[fragment_mass__1][fragment_mass_0_0001][substructure_id] for substructure_id in mf_to_substructure_id[fragment_mf]]
                        )

    return substructure_subsets


def gen_subs_table(db, ha_min, ha_max, max_degree, max_atoms_available, max_mass, table_name="subset",
                   minimum_frequency=None):
    """
    Generate a temporary secondary substructure table restricted by a set of parameters. Generated as an initial step
    in :py:meth:`metaboblend.build_structures.generate_structures` and
    :py:meth:`metaboblend.build_structures.annotate_msn` in order to limit the processing overhead as a result of
    repeatedly querying the SQLite substructure database.

    :param max_mass: The maximum allowed mass of substructures in the temporary table; there is no point considering
        substructures with greater mass than the target mol.

    :param db: Connection to a :py:meth:`metaboblend.databases.SubstructureDb` from which to extract substructures.

    :param ha_min: Minimum value of `heavy_atoms` for substructures to be transferred into the temporary table.
        If None, no limit is applied.

    :param ha_max: Maximum value of `heavy_atoms` for substructures to be transferred into the temporary table.
        If None, no limit is applied.

    :param max_degree: The maximum total valence (ie, the product of `atoms_available` and the degree of their bonds)
        to be included in the temporary table.

    :param max_atoms_available: The maximal atoms available of substructures to be included in the temporary table.

    :param table_name: Defaults to "subset_substructures", which is cleaned up upon database closure. The name of the
        table to be generated

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique.

    :return: The name of the temporary secondary substructure table.
    """

    db.cursor.execute("DROP TABLE IF EXISTS %s" % (table_name + "_substructures"))
    db.cursor.execute("DROP TABLE IF EXISTS %s" % (table_name + "_substructure_ions"))

    if minimum_frequency is None:
        freq_statement = ""
    else:
        freq_statement = """
                            AND smiles IN 
                                (SELECT smiles 
                                    FROM hmdbid_substructures 
                                    GROUP BY smiles 
                                    HAVING COUNT(*) >= {})
                         """.format(minimum_frequency,)

    if ha_min is None:
        ha_min_statement = ""
    else:
        ha_min_statement = """
                              AND heavy_atoms >= %s""" % str(ha_min)

    if ha_max is None:
        ha_max_statement = ""
    else:
        ha_max_statement = """
                              AND heavy_atoms <= %s""" % str(ha_max)

    if max_mass is None:
        max_mass_statement = ""
    else:
        max_mass_statement = """
                                AND exact_mass__1 < %s""" % str(max_mass)

    db.temporary_table_names.append(table_name + "_substructures")

    db.cursor.execute("""CREATE TABLE {} (
                               substructure_id INTEGER PRIMARY KEY,
                               smiles TEXT NOT NULL UNIQUE, 
                               heavy_atoms INTEGER,
                               length INTEGER,
                               exact_mass__1 INTEGER,
                               exact_mass__0_0001 REAL,
                               exact_mass REAL,
                               C INTEGER,
                               H INTEGER,
                               N INTEGER,
                               O INTEGER,
                               P INTEGER,
                               S INTEGER,
                               valence INTEGER,
                               valence_atoms TEXT,
                               atoms_available INTEGER,
                               bond_types TEXT,
                               dummies TEXT,
                               mol BLOB)
                      """.format(
                               table_name + "_substructures",
                               table_name + "_substructure_ions"
                         ))

    db.cursor.execute("""INSERT INTO {}
                             SELECT * 
                                 FROM substructures
                                 WHERE atoms_available <= {}
                                 AND valence <= {}{}{}{}{}
                      """.format(
                             table_name + "_substructures",
                             max_atoms_available,
                             max_degree,
                             max_mass_statement,
                             freq_statement,
                             ha_min_statement,
                             ha_max_statement
                      ))

    db.temporary_table_names.append(table_name + "_substructure_ions")

    db.cursor.execute("""CREATE TABLE {}_substructure_ions (
                               substructure_id INTEGER, 
                               hydrogen_modification INTEGER, 
                               ion_mode_positive BOOLEAN,
                               modified_exact_mass__1 INTEGER, 
                               modified_exact_mass__0_0001 REAL,
                               PRIMARY KEY (substructure_id, hydrogen_modification, ion_mode_positive),
                               FOREIGN KEY (substructure_id) REFERENCES {}_substructures(substructure_id))
                      """.format(table_name, table_name))

    db.cursor.execute("""INSERT INTO {}
                             SELECT *
                                 FROM substructure_ions
                                 WHERE substructure_id IN (SELECT substructure_id FROM {})
                      """.format(
                             table_name + "_substructure_ions",
                             table_name + "_substructures"
                         ))

    db.conn.commit()
    db.create_temp_indexes(table_name)

    return table_name


def build_from_subsets(exact_subset, mf, table_name, db, fragment_substructures=None):
    """
    A stage of the :py:meth:`metaboblend.build_structures.build` workflow for generating molecules to a given mass
    from substructures. At this stage, mass subsets have been identified in the substructure database. Each of these
    groups are now filtered further by identifying masses that refer to valid subsets of molecules, before they are
    built to generate new molecules.

    :param db: The substructure and connectivity database. Elemental compositions and substructures are retrieved from
        the database; this information is listed as "substructure_subset" and will be appended to the
        substructure_subsets list provided as a parameter.

    :param exact_subset: Group of masses that sum to the correct total mass, refer to substructures in the substructure
        database.

    :param mf: List of integers detailing the molecular composition of the target metabolite, in the format
        `[C, H, N, O, P, S]`.

    :param table_name: The name of the table within the substructure database from which to extract substructures. A
        prefiltered table based on the parameters specified in :py:meth:`metaboblend.build_structures.build`. See
        :py:meth:`metaboblend.build_structures.gen_subs_table`.

    :param fragment_substructures: If None, standard building from the input mass subset is carried out. Else,
        represents the retrieved candidate fragment substructures to be combined with the substructures of the input
        mass subset.

    :return: Returns a list in the same format as the input mass subset, `exact_subset`. Instead of masses (floats),
        the substructures are now represented by dictionaries, as retreived by
        :py:meth:`metaboblend.build_structures.get_possible_fragment_ions`.
    """

    substructure_subsets = []
    mf_subset = combine_mfs(exact_subset, db, table_name, "0_0001")

    if len(mf_subset) == 0:
        return []

    for ec_product in itertools.product(*mf_subset):

        if mf != list(numpy.array(ec_product).sum(axis=0)):
            continue  # check each set of elemental compositions matches the target mol

        substructure_subset = db.select_substructures(ec_product, table_name)

        if len(substructure_subset) == 0:
            continue

        if fragment_substructures is None:
            substructure_subsets.append(substructure_subset)
        else:
            substructure_subsets.append([fragment_substructures] + substructure_subset)

    return substructure_subsets


def get_bond_enthalpies():
    """ Gets predicted bond dissociation energies for each bond type and elemental composition. """

    return {1.0: {'C': {'C':  348, 'N':  305, 'O':  360, 'P':  264, 'S':  272},
                  'N': {'C':  305, 'N':  163, 'O':  222, 'P': None, 'S': None},
                  'O': {'C':  360, 'N':  222, 'O':  146, 'P':  335, 'S': None},
                  'P': {'C':  264, 'N': None, 'O':  335, 'P':  201, 'S': None},
                  'S': {'C':  272, 'N': None, 'O': None, 'P': None, 'S':  226}},
            1.5: {'C': {'C':  837, 'N':  890, 'O': None, 'P': None, 'S': None},
                  'N': {'C':  890, 'N':  944, 'O': None, 'P': None, 'S': None},
                  'O': {'C': None, 'N': None, 'O': None, 'P': None, 'S': None},
                  'P': {'C': None, 'N': None, 'O': None, 'P': None, 'S': None},
                  'S': {'C': None, 'N': None, 'O': None, 'P': None, 'S': None}},
            2.0: {'C': {'C':  612, 'N':  613, 'O':  743, 'P': None, 'S':  573},
                  'N': {'C':  613, 'N':  409, 'O':  607, 'P': None, 'S': None},
                  'O': {'C':  743, 'N':  607, 'O':  496, 'P':  544, 'S':  522},
                  'P': {'C': None, 'N': None, 'O':  544, 'P': None, 'S':  335},
                  'S': {'C':  573, 'N': None, 'O':  522, 'P':  335, 'S':  425}}}


def substructure_combination_build(substructure_subset, configs_iso, prescribed_method, isomeric_smiles,
                                   bond_enthalpies, retain_substructures):
    """
    Final stage for building molecules; takes a combination of substructures (substructure_combination) and builds them
    according to graphs in the substructure database. May be run in parallel.

    :param substructure_subset: Combinations of substructures for building mols.

    :param configs_iso: Possible substructure combinations extracted from the connectivity database. A tuple containing
        tuples for each substructure; these tuples specify how many bonds each substructure can make.

    :param prescribed_method: If True, assumes the first substructure in `substructure_subset` to be the fragment
        substructure.

    :param isomeric_smiles: True/False, should output smiles be written with isomeric information?

    :param bond_enthalpies: Dictionary of bond enthalpies, as generated by
    :py:meth:`metaboblend.build_structures.get_bond_enthalpies`.

    :param retain_substructures: Whether to record the substructures used to generate final structures.

    :return: List of smiles representing molecules generated (and the substructures used to generate them).
    """

    smis = {}

    for substructure_combination in itertools.product(*substructure_subset):

        if prescribed_method:
            substructure_combination[0]["fragment"] = True
            even_fragment = substructure_combination[0]["even"]

        substructure_combination = sorted(substructure_combination, key=itemgetter('atoms_available', 'valence'))

        v_a = ()
        j = -1

        if prescribed_method:
            fragment_indexes = []

        for i, d in enumerate(substructure_combination):

            v_a += (tuple(d["degree_atoms"].values()),)  # obtain valence configuration of the set of substructures

            for atom_available in tuple(d["degree_atoms"].values()):
                j += 1

                try:
                    if prescribed_method:
                        if d["fragment"]:
                            fragment_indexes.append(j)

                except KeyError:
                    continue

        if str(v_a) not in configs_iso:  # check mols "fit" together according to the connectivity database
            continue

        mol_comb, atoms_available, atoms_to_remove, bond_types, bond_mismatch = reindex_atoms(substructure_combination)

        if bond_mismatch:
            continue  # check that bond types are compatible (imperfect check)

        for edges in configs_iso[str(v_a)]:  # build mols for each graph in connectivity db
            if prescribed_method:
                non_fragment_edges = False

                for edge in edges:  # check that edges only connect to fragment ion
                    if edge[0] not in fragment_indexes and edge[1] not in fragment_indexes:
                        non_fragment_edges = True

                if non_fragment_edges:
                    continue

            # add bonds between substructures
            mol_e, total_bde = add_bonds(mol_comb, edges, atoms_available, bond_types, bond_enthalpies)

            if mol_e is None or total_bde is None:
                continue

            atoms_to_remove.sort(reverse=True)
            [mol_e.RemoveAtom(a) for a in atoms_to_remove]  # clean up dummy atoms

            mol_out = mol_e.GetMol()  # generate the final (non-editable) mol

            try:
                Chem.SanitizeMol(mol_out)  # clean the mol - ensure it is valid & canonical
            except:
                continue

            try:  # append the canonical smiles of the final structure
                final_structure = Chem.MolToSmiles(mol_out, isomericSmiles=isomeric_smiles)

            except RuntimeError:
                continue  # bad bond type violation

            final_substructures = [subs["smiles"] for subs in substructure_combination]

            try:
                smis[final_structure]["bdes"].append(total_bde)

                if retain_substructures:
                    smis[final_structure]["substructures"].append(final_substructures)

            except KeyError:
                smis[final_structure] = {"bdes": [total_bde]}

                if prescribed_method:
                    smis[final_structure]["even"] = even_fragment

                if retain_substructures:
                    smis[final_structure]["substructures"] = [final_substructures]

    return smis
