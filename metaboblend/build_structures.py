#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright Â© 2019-2020 Ralf Weber
#
# This file is part of MetaboBlend.
#
# MetaboBlend is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MetaboBlend is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MetaboBlend.  If not, see <https://www.gnu.org/licenses/>.
#

import os
import multiprocessing
import copy
import itertools
from functools import partial
import networkx as nx
import numpy
import sqlite3
import csv
from operator import itemgetter
from typing import Sequence, Dict, Union

from rdkit import Chem

from .databases import SubstructureDb, get_elements, calculate_exact_mass


def find_path(mass_list, sum_matrix, n, mass, max_subset_length, path=[]):
    """
    Recursive solution for backtracking through the dynamic programming boolean matrix. All possible subsets are found

    :param mass_list: A list of masses from which to identify subsets.

    :param mass: The target mass of the sum of the substructures.

    :param sum_matrix: The dynamic programming boolean matrix.

    :param n: The size of mass_list.

    :param max_subset_length: The maximum length of subsets to return. Allows the recursive backtracking algorithm to
        terminate early in many cases, significantly improving runtime.

    :param path: List for keeping track of the current subset.

    :return: Generates of lists containing the masses of valid subsets.
    """

    # base case - the path has generated a correct solution
    if mass == 0:
        yield sorted(path)
        return

    # stop running when we overshoot the mass
    elif mass < 0:
        return

    # can we sum up to the target value using the remaining masses? recursive call
    elif sum_matrix[n][mass]:
        yield from find_path(mass_list, sum_matrix, n - 1, mass, max_subset_length, path)

        if len(path) < max_subset_length:
            path.append(mass_list[n-1])

            yield from find_path(mass_list, sum_matrix, n - 1, mass - mass_list[n - 1], max_subset_length, path)
            path.pop()


def subset_sum(mass_list, mass, max_subset_length=3):
    """
    Dynamic programming implementation of subset sum. Note that, whilst this algorithm is pseudo-polynomial, the
    backtracking algorithm for obtaining all possible subsets has exponential complexity and so remains unsuitable
    for large input values.  This does, however, tend to perform a lot better than non-sum_matrix implementations, as
    we're no longer doing sums multiple times and we've cut down the operations performed during the exponential portion
    of the method.

    :param mass_list: A list of masses from which to identify subsets.

    :param mass: The target mass of the sum of the substructures.

    :param max_subset_length: The maximum length of subsets to return. Allows the recursive backtracking algorithm to
        terminate early in many cases, significantly improving runtime.

    :return: Generates of lists containing the masses of valid subsets.
    """

    n = len(mass_list)

    # initialise dynamic programming array
    sum_matrix = numpy.ndarray([n + 1, mass + 1], bool)

    # subsets can always equal 0
    for i in range(n+1):
        sum_matrix[i][0] = True

    # empty subsets do not have non-zero sums
    for i in range(mass):
        sum_matrix[0][i + 1] = False

    # fill in the remaining boolean matrix
    for i in range(n):
        for j in range(mass+1):
            if j >= mass_list[i]:
                sum_matrix[i + 1][j] = sum_matrix[i][j] or sum_matrix[i][j - mass_list[i]]
            else:
                sum_matrix[i + 1][j] = sum_matrix[i][j]

    # backtrack through the matrix recursively to obtain all solutions
    return find_path(mass_list, sum_matrix, n, mass, max_subset_length)


def combine_mfs(precise_mass_grp, db, table_name, accuracy):
    """
    A wrapper for :py:meth:`metaboblend.databases.select_ecs` that instead takes a group of subsets, as generated by
    the second stage of :py:meth:`metaboblend.build_structures.subset_sum` in
    :py:meth:`metaboblend.build_structures.build`.

    :param precise_mass_grp: A list containing the masses of substructures identified by subset_sum.

    :param db: The :py:meth:`metaboblend.databases.SubstructureDb` in which to search for elemental compositions.

    :param table_name: The name of the table containing substructures in which to search for elemental compositions.

    :param accuracy: To which decimal places of accuracy results are to be limited to.

            * **1** Integer level
            * **0_0001** Four decimal places

    :return: If there are no elemental compositions for any of the masses in the group, then an empty list is returned.
    """

    ecs = []

    for i in range(len(precise_mass_grp)):
        atoms = db.select_mfs(precise_mass_grp[i], table_name, accuracy)

        if len(atoms) == 0:
            return []

        ecs.append(atoms)

    return ecs


def reindex_atoms(records):
    """
    Parses the libs of groups of substructures that are to be combined; the lib is a dictionary containing details
    about the substructure, as generated by :py:meth:`metaboblend.databases.get_substructure`. Combines the
    molecules into a single :py:meth:`rdkit.Chem.Mol` object and obtains details on their bonding properties.

    :param records: Takes a list of lib dictionaries that contain details on each substructure to be combined.

    :return: Returns a tuple containing a :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule, followed by information on the substructure bonding properties, including:

        * **atoms_available** A list of the indices of atoms that are available for bonding.

        * **atoms_to_remove** A list of the indices of dummy atoms that are to be removed in order to bond with other
        substructures.

        * **bond_types** A dictionary containing the indices of atoms that are available for bonding as keys and values
        detailing their bond types. See :py:meth:`metaboblend.build_structures.add_bonds`.
    """

    atoms_available, atoms_to_remove, bond_types = [], [], {}
    mol_comb = Chem.Mol()
    index_atoms, all_bond_types = [], {}
    c = 0

    for i, record in enumerate(records):
        idxs = []
        all_bond_types[i] = []
        for atom in record["mol"].GetAtoms():

            new_idx = atom.GetIdx() + c
            idxs.append(new_idx)

            if atom.GetIdx() in record["degree_atoms"]:
                atoms_available.append(new_idx)

            if atom.GetIdx() in record["dummies"]:
                atoms_to_remove.append(new_idx)

            if atom.GetIdx() in record["bond_types"]:
                bond_types[new_idx] = record["bond_types"][atom.GetIdx()]
                all_bond_types[i] += record["bond_types"][atom.GetIdx()]

        mol_comb = Chem.CombineMols(mol_comb, record["mol"])
        index_atoms.append(idxs)
        c = idxs[-1] + 1

    # check that bond types add up - removes some mismatched configurations
    bond_mismatch = False
    for i in range(len(records)):
        other_bonds = []
        for j in range(len(records)):
            if i != j:
                other_bonds += all_bond_types[j]

        for bond in all_bond_types[i]:
            if bond not in other_bonds:
                bond_mismatch = True

    return mol_comb, atoms_available, atoms_to_remove, bond_types, bond_mismatch


def add_bonds(mols, edges, atoms_available, bond_types, bond_enthalpies):
    """
    Takes a set of substructures and attempts to combine them together to generate a final structure. One of the last
    steps in the :py:meth:`metaboblend.build_structures.build` workflow.

    :param mols: A :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule.

    :param edges: The edges to use in order to join the substructures together, obtained from the connectivity database
        (:py:meth:`metaboblend.databases.create_isomorphism_database`).

    :param atoms_available: A list of the indices of atoms that are available for bonding.

    :param bond_types:  The type of bonds to be formed by dummy atoms - see :py:meth:`Chem.rdchem.BondType`. Is a
        dictionary whose keys are atom indices and values are bond types, as follows:

            * **1.0** Single

            * **1.5** Aromatic

            * **2.0** Double

    :return: If unsuccessful, returns None, else returns an :py:meth:`rdkit.Chem.EditableMol` object containing
        the substructures combined into a final single molecule.
    """

    rdkit_bond_types = {1: Chem.rdchem.BondType.SINGLE,
                        1.5: Chem.rdchem.BondType.AROMATIC,
                        2: Chem.rdchem.BondType.DOUBLE}

    bond_types_copy = copy.deepcopy(bond_types)  # deep copy as we modify items within the dict

    g = nx.Graph()
    g.add_edges_from(edges)

    g = nx.relabel_nodes(g, dict(zip(sorted(g.nodes()), atoms_available)))

    total_bde = 0

    mol_edit = Chem.EditableMol(mols)
    for edge in g.edges():

        if edge[0] in bond_types_copy:
            bt_start = bond_types_copy[edge[0]]
        else:
            return None, None  # nested dummy

        if edge[1] in bond_types_copy:
            bt_end = bond_types_copy[edge[1]]
        else:
            return None, None  # nested dummy

        bond_matches = list(set(bt_start).intersection(bt_end))

        if len(bond_matches) == 0:
            return None, None

        else:
            bt_start.remove(bond_matches[0])
            bt_end.remove(bond_matches[0])

        try:
            mol_edit.AddBond(edge[0], edge[1], rdkit_bond_types[bond_matches[0]])
        except KeyError:
            return None, None  # unknown bond type

        try:
            total_bde += bond_enthalpies[bond_matches[0]][mols.GetAtomWithIdx(edge[0]).GetSymbol()][mols.GetAtomWithIdx(edge[1]).GetSymbol()]
        except (SyntaxError, TypeError):
            total_bde = None

    return mol_edit, total_bde


class ResultsDb:
    """
    Methods for interacting with the SQLITE3 results database, as created by
    :py:meth:`metaboblend.build_structures.annotate_msn`.

    :param path_results: Directory to which results will be written.
    """

    def __init__(self, path_results, msn=True):
        """Constructor method."""

        self.path_results = path_results
        self.path_results_db = os.path.join(self.path_results, "metaboblend_results.sqlite")
        self.msn = msn

        self.conn = None
        self.cursor = None

    def connect(self):
        """Connects to the results database."""

        self.conn = sqlite3.connect(self.path_results_db)
        self.cursor = self.conn.cursor()

    def create_results_db(self):
        """Generates a new results database."""

        if os.path.exists(self.path_results_db):
            os.remove(self.path_results_db)

        self.connect()

        self.cursor.execute("""CREATE TABLE queries (
                                   ms_id_num NUMERIC PRIMARY KEY,
                                   ms_id TEXT,
                                   exact_mass NUMERIC,
                                   C INTEGER,
                                   H INTEGER,
                                   N INTEGER,
                                   O INTEGER,
                                   P INTEGER,
                                   S INTEGER,
                                   ppm INTEGER,
                                   ha_min INTEGER,
                                   ha_max INTEGER,
                                   max_atoms_available INTEGER,
                                   max_degree INTEGER,
                                   max_n_substructures INTEGER,
                                   hydrogenation_allowance INTEGER,
                                   isomeric_smiles INTEGER)""")

        if self.msn:
            self.cursor.execute("""CREATE TABLE spectra (
                                       ms_id_num NUMERIC,
                                       fragment_id NUMERIC,
                                       neutral_mass NUMERIC,
                                       PRIMARY KEY (ms_id_num, fragment_id))""")

        self.cursor.execute("""CREATE TABLE structures (
                                   ms_id_num NUMERIC,
                                   structure_smiles TEXT,
                                   frequency NUMERIC,
                                   PRIMARY KEY (ms_id_num, structure_smiles))""")

        self.cursor.execute("""CREATE TABLE substructures (
                                           structure_smiles TEXT ,
                                           substructure_smiles TEXT,
                                           PRIMARY KEY (structure_smiles, substructure_smiles))""")

        self.cursor.execute("""CREATE TABLE results (
                                   ms_id_num NUMERIC,
                                   fragment_id NUMERIC,
                                   structure_smiles TEXT,
                                   bde NUMERIC,
                                   PRIMARY KEY(ms_id_num, fragment_id, structure_smiles))""")

        self.conn.commit()

    def add_ms(self, msn_data, ms_id, ms_id_num, parameters):
        """
        Add entries to the `queries` and `spectra` tables.

        :param msn_data: Dictionary in the form
            `msn_data[id] = {mf: [C, H, N, O, P, S], exact_mass: float, fragment_masses: []}`. id represents a unique
            identifier for a given spectral tree or fragmentation spectrum, mf is a list of integers referring to the
            molecular formula of the structure of interest, exact_mass is the mass of this molecular formula to >=4d.p.
            and fragment_masses are neutral fragment masses generated by this structure used to inform candidate
            scoring. See :py:meth:`metaboblend.build_structures.annotate_msn`.

        :param ms_id: Unique identifier for the annotation of a single metabolite.

        :param ms_id_num: Unique numeric identifier for the annotation of a single metaoblite.

        :param parameters: List of parameters, in the form: [ppm, ha_min, ha_max, max_atoms_available, max_degree,
            max_n_substructures, hydrogenation_allowance, isomeric_smiles]. See
            :py:meth:`metaboblend.build_structures.annotate_msn`.
        """

        for i, parameter in enumerate(parameters):
            if parameter is None:
                parameters[i] = "NULL"
            elif isinstance(parameter, bool):
                parameters[i] = int(parameter)

        self.cursor.execute("""INSERT INTO queries (
                                   ms_id,
                                   ms_id_num,
                                   exact_mass,
                                   C, H, N, O, P, S,
                                   ppm,
                                   ha_min,
                                   ha_max,
                                   max_atoms_available,
                                   max_degree,
                                   max_n_substructures,
                                   hydrogenation_allowance,
                                   isomeric_smiles
                               ) VALUES ('{}', {}, {}, '{}', '{}', '{}', '{}', '{}', '{}', {})""".format(
                                   ms_id,
                                   ms_id_num,
                                   msn_data[ms_id]["exact_mass"],
                                   msn_data[ms_id]["mf"][0], msn_data[ms_id]["mf"][1],
                                   msn_data[ms_id]["mf"][2], msn_data[ms_id]["mf"][3],
                                   msn_data[ms_id]["mf"][4], msn_data[ms_id]["mf"][5],
                                   ", ".join([str(p) for p in parameters])
                               ))

        self.conn.commit()

    def add_results(self, ms_id_num, smi_dict, fragment_mass=None, fragment_id=None):
        """
        Record which smiles were generated for a given fragment mass.

        :param ms_id_num: Unique identifier for the annotation of a single metabolite.

        :param smi_dict: The fragment and substructure smiles generated by the annotation of a single peak for a single
            metabolite.

        :param fragment_mass: The neutral fragment mass that has been annotated.

        :param fragment_id: The unique identifier for the fragment mass that has been annotated.
        """

        if self.msn:
            self.cursor.execute("""INSERT OR IGNORE INTO spectra (
                                                       ms_id_num,
                                                       fragment_id,
                                                       neutral_mass
                                                   ) VALUES ('{}', {}, {})""".format(
                                                       ms_id_num,
                                                       fragment_id,
                                                       fragment_mass
                                                   ))
        else:
            fragment_id = "NULL"

        for structure_smiles in smi_dict.keys():
            self.cursor.execute("""INSERT OR IGNORE INTO results (
                                       ms_id_num,
                                       fragment_id,
                                       structure_smiles,
                                       bde
                                   ) VALUES ('{}', '{}', '{}', '{}')""".format(
                                       ms_id_num,
                                       fragment_id,
                                       structure_smiles,
                                       smi_dict[structure_smiles][0]
                                   ))

            for substructure_smiles in smi_dict[structure_smiles][1]:

                self.cursor.execute("""INSERT OR IGNORE INTO substructures (
                                                   structure_smiles,
                                                   substructure_smiles
                                               ) VALUES ('{}', '{}')""".format(
                                                   structure_smiles,
                                                   substructure_smiles
                                               ))

        self.conn.commit()

    def calculate_frequencies(self, ms_id_num):
        """
        Calculates structure frequencies in the SQLite DB.

        :param ms_id_num: Unique identifier for the annotation of a single metabolite.
        """

        self.cursor.execute("""INSERT INTO structures (ms_id_num, structure_smiles, frequency) 
                                   SELECT ms_id_num, structure_smiles, COUNT(*)
                                   FROM results 
                                   WHERE ms_id_num = {}
                                   GROUP BY structure_smiles""".format(ms_id_num))

    def get_structures(self, ms_id_num):
        """
        Gets smiles of generated structures. In the case of the MSn annotation workflow, also gets structure
        frequencies.

        :param ms_id_num: Unique identifier for the annotation of a single metabolite.

        :return: In the case of simple structure generation, returns a set of smiles strings for output structures.
            For the MSn annotation workflow, returns a dictionary with smiles as keys and the number of peaks for which
            the smiles were generated as values.
        """

        if self.msn:
            msn_str = ", frequency"
        else:
            msn_str = ""

        self.cursor.execute("""SELECT structure_smiles{} FROM structures 
                                   WHERE ms_id_num = {}
                            """.format(msn_str, ms_id_num))

        if self.msn:
            return [t for t in self.cursor.fetchall()]
        else:
            return [item for t in self.cursor.fetchall() for item in t]

    def generate_csv_output(self):
        """
        Generate CSV file output for i) queries and tool parameters and ii) structures generated.
        """

        with open(os.path.join(self.path_results, "metaboblend_queries.csv"), "w", newline="") as results_file, \
             open(os.path.join(self.path_results, "metaboblend_structures.csv"), "w", newline="") as ms_file:

            results_writer = csv.writer(results_file, delimiter=",")
            ms_writer = csv.writer(ms_file, delimiter=",")

            results_writer.writerow(["ms_id", "exact_mass", "C", "H", "N", "O", "P", "S", "ppm", "ha_min", "ha_max",
                                     "max_atoms_available", "max_degree", "max_n_substructures",
                                     "hydrogenation_allowance", "isomeric_smiles"])

            self.cursor.execute("SELECT * FROM queries")

            for query in self.cursor.fetchall():
                results_writer.writerow(query)

            ms_writer.writerow(["ms_id", "smiles", "frequency", "exact_mass", "C", "H", "N", "O", "P", "S"])

            self.cursor.execute("SELECT * FROM structures")

            for structure in self.cursor.fetchall():
                ms_writer.writerow(structure)

    def close(self):
        """Close the connection to the SQLITE3 database."""

        self.conn.close()


def annotate_msn(msn_data: Dict[str, Dict[str, Union[int, list]]],
                 path_substructure_db: Union[str, bytes, os.PathLike] = os.path.realpath(os.getcwd()),
                 path_out: Union[str, bytes, os.PathLike] = "",
                 ppm: int = 5,
                 ha_min: Union[int, None] = None,
                 ha_max: Union[int, None] = None,
                 max_atoms_available: int = 2,
                 max_degree: int = 6,
                 max_n_substructures: int = 3,
                 path_connectivity_db: Union[str, bytes, os.PathLike, None] = None,
                 ncpus: Union[int, None] = None,
                 minimum_frequency: Union[int, None] = None,
                 hydrogenation_allowance: int = 2,
                 yield_smis: bool = True,
                 isomeric_smiles: bool = False,
                 write_csv_output: bool = True
                 ) -> Dict[str, Sequence[Dict[str, int]]]:
    """
    Generate molecules of a given mass using chemical substructures, connectivity graphs and spectral trees or
    fragmentation spectra. Final structures and rankings are yielded by the function as a dictionary and/or written in
    text format. For the generation of structures without MSn data, see
    :py:meth:`metaboblend.build_structures.generate_structures`.

    :param msn_data: Dictionary in the form
        `msn_data[id] = {mf: [C, H, N, O, P, S], exact_mass: float, fragment_masses=[]}`. id represents a unique
        identifier for a given spectral tree or fragmentation spectrum, mf is a list of integers referring to the
        molecular formula of the structure of interest, exact_mass is the mass of this molecular formula to >=4d.p.
        and fragment_masses are neutral fragment masses generated by this structure used to inform candidate scoring.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param path_out: Folder to which the SQLite 3 results database and CSV outputs should be written.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param ha_min: The minimum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param ha_max: The maximum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param max_atoms_available: The maximum number of  atoms available of each substructure to be considered for
        building molecules. `atoms_available` refers to the number of atoms on a substructure involved in forming
        chemical bonds (e.g. single or double bonds). `atoms_available` are also limited by the extensivity of the
        supplied connectivity database.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single, 
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For 
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have 
        a total degree of 3.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. The max number
        of substructures is also limited by the extensivity of the supplied connectivity database.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`. If the path is None, the default connectivity
        database bundled with MetaboBlend will be used.

    :param ncpus: How many CPUs to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique. Defaults to None, in which case this filtering method is not applied.

    :param hydrogenation_allowance: In order to represent re-arrangement events (the movement of hydrogens), in
        addition to attempting to build from substructures in prescribed_masses, we also attempt to build from
        `fragment_masses +- hydrogenation_allowance`. E.g. if `prescribed_masses = [141.5938]` and
        `hydrogenation_allowance = 1` then, to find candidate fragment substructures, we use as query the masses
        `[141.5938 - 1.007825, 141.5938, 141.5938 + 1.007825]`.

    :param yield_smis: If True, for each input molecule the function yields SMILEs the number of `fragment_masses` by
        which the structure was generated. Else, returns None.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :param write_csv_output: Whether to extract results from the SQLite3 database for deposition in CSV files.

    :return: For each input molecule yields a dictionary whose keys are SMILEs strings for the generated
        structures and values are the number of `fragment_masses` by which the structure was built (unless
        `yield_smi_dict = False`).
    """

    if ppm is None:
        ppm = 0

    if path_connectivity_db is None:
        path_connectivity_db = os.path.join(os.path.realpath(os.path.dirname(__file__)), "data", "connectivity.sqlite")

    db = SubstructureDb(path_substructure_db, path_connectivity_db)
    results_db = ResultsDb(path_out)
    results_db.create_results_db()

    # prepare temporary table here - will only be generated once in case of multiple input
    table_name = gen_subs_table(
        db=db,
        ha_min=ha_min,
        ha_max=ha_max,
        max_degree=max_degree,
        max_atoms_available=max_atoms_available,
        minimum_frequency=minimum_frequency,
        max_mass=round(max([msn_data[ms_id]["exact_mass"] for ms_id in msn_data.keys()]))
    )

    for i, ms_id in enumerate(msn_data.keys()):

        results_db.add_ms(msn_data, ms_id, i,
                          [ppm, ha_min, ha_max, max_atoms_available, max_degree, max_n_substructures, hydrogenation_allowance, isomeric_smiles])

        for j, fragment_mass in enumerate(msn_data[ms_id]["fragment_masses"]):

            for k in range(0 - hydrogenation_allowance, hydrogenation_allowance + 1):
                hydrogenated_fragment_mass = fragment_mass + (k * 1.007825)  # consider re-arrangements

                smi_dict = build(
                    mf=msn_data[ms_id]["mf"],
                    exact_mass=msn_data[ms_id]["exact_mass"],
                    max_n_substructures=max_n_substructures,
                    path_connectivity_db=path_connectivity_db,
                    path_substructure_db=path_substructure_db,
                    prescribed_mass=hydrogenated_fragment_mass,
                    ppm=ppm,
                    table_name=table_name,
                    ncpus=ncpus,
                    clean=False,
                    isomeric_smiles=isomeric_smiles
                )

                results_db.add_results(i, smi_dict, fragment_mass, j)
                fragment_smis = None

        results_db.calculate_frequencies(i)

        if yield_smis:
            yield {ms_id: results_db.get_structures(i)}

    if write_csv_output:
        results_db.generate_csv_output()

    db.close()
    results_db.close()


def generate_structures(ms_data: Dict[str, Dict[str, Union[int, None]]],
                        path_substructure_db: Union[str, bytes, os.PathLike],
                        path_out: Union[str, bytes, os.PathLike] = os.path.realpath(os.getcwd()),
                        ha_min: Union[int, None] = 2,
                        ha_max: Union[int, None] = 9,
                        max_degree: int = 6,
                        max_atoms_available: int = 2,
                        max_n_substructures: int = 3,
                        ncpus: Union[int, None] = None,
                        path_connectivity_db: Union[str, bytes, os.PathLike, None] = None,
                        minimum_frequency: Union[int, None] = None,
                        yield_smis: bool = True,
                        isomeric_smiles: bool = False,
                        write_csv_output: bool = True,
                        ) -> Dict[str, Sequence[set]]:
    """
    Generate molecules of a given mass using chemical substructures and connectivity graphs. Can optionally take a
    "prescribed" fragment mass to further filter results. Final structures are returned as a list and/or written in
    text format. For the generation of structures from MSn data, see
    :py:meth:`metaboblend.build_structures.annotate_msn`.

    :param ms_data: Dictionary in the form ms_data[id] =
        `{mf: [C, H, N, O, P, S], exact_mass: float, prescribed_mass=int}`. id represents a unique identifier for
        a given test, mf is a list of integers referring to molecular formula of the structure of interest,
        exact_mass is the mass of this structure to >=4d.p. and prescribed_mass is the neutral mass of a substructure
        used to limit structures generated.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param path_out: Folder to which the SQLite 3 results database and CSV outputs should be written.

    :param ha_min: The minimum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param ha_max: The maximum size (number of heavy atoms) of substructures to be used to build final structures. If
        None, no limit is applied.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single,
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have
        a total degree of 3.

    :param max_atoms_available: The maximum number of  atoms available of each substructure to be considered for
        building molecules. `atoms_available` refers to the number of atoms on a substructure involved in forming
        chemical bonds (e.g. single or double bonds). `atoms_available` are also limited by the extensivity of the
        supplied connectivity database.

    :param max_degree: The maximum allowable degree of substructures to be considered for building structures. We
        define degree as the product of `atoms_available` and the degree of their bonds (bond types, where 1 = single,
        2 = double, etc.). Maximum degree is also limited by the extensivity of the supplied connectivity database. For
        instance, a substructure that has 3 `atoms_available`, each of their bond types being single bonds, would have
        a total degree of 3.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules. The max number
        of substructures is also limited by the extensivity of the supplied connectivity database.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`. If the path is None, the default connectivity
        database bundled with MetaboBlend will be used.

    :param ncpus: How many worker processes to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique. Defaults to None, in which case this filtering method is not applied.

    :param yield_smis: If True, yields a set of unique SMILEs string for each input molecule, else returns None.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :param write_csv_output: Whether to extract results from the SQLite3 database for deposition in CSV files.

    :return: For each input molecule, yields unique SMILEs strings (unless `yield_smis = False`).
    """

    db = SubstructureDb(path_substructure_db, path_connectivity_db)
    results_db = ResultsDb(path_out, False)
    results_db.create_results_db()

    if path_connectivity_db is None:
        path_connectivity_db = os.path.join(os.path.realpath(os.path.dirname(__file__)), "data", "connectivity.sqlite")

    # prepare temporary table here - will only be generated once in case of multiple input
    table_name = gen_subs_table(
        db=db,
        ha_min=ha_min,
        ha_max=ha_max,
        max_degree=max_degree,
        max_atoms_available=max_atoms_available,
        minimum_frequency=minimum_frequency,
        max_mass=round(max([ms_data[ms_id]["exact_mass"] for ms_id in ms_data.keys()]))
    )

    for i, ms_id in enumerate(ms_data.keys()):

        results_db.add_ms(ms_data, ms_id, i,
                          [None, ha_min, ha_max, max_atoms_available, max_degree, max_n_substructures, None, isomeric_smiles])

        ppm = None

        try:
            if ms_data[ms_id]["prescribed_masses"] is not None:
                ppm = 0
        except KeyError:
            ms_data[ms_id]["prescribed_masses"] = None

        smi_dict = build(
            mf=ms_data[ms_id]["mf"],
            exact_mass=ms_data[ms_id]["exact_mass"],
            max_n_substructures=max_n_substructures,
            path_connectivity_db=path_connectivity_db,
            path_substructure_db=path_substructure_db,
            prescribed_mass=ms_data[ms_id]["prescribed_masses"],
            ppm=ppm,
            table_name=table_name,
            ncpus=ncpus,
            clean=False,
            isomeric_smiles=isomeric_smiles
        )

        results_db.add_results(i, smi_dict, ms_data[ms_id]["prescribed_masses"])
        results_db.calculate_frequencies(i)

        if yield_smis:
            yield {ms_id: results_db.get_structures(i)}

    if write_csv_output:
        results_db.generate_csv_output()

    db.close()


def build(mf, exact_mass, max_n_substructures, path_connectivity_db, path_substructure_db,
          prescribed_mass, ppm, ncpus, table_name, clean, isomeric_smiles):
    """
    Core function for generating molecules of a given mass using substructures and connectivity graphs. Can optionally
    take a "prescribed" fragment mass to further filter results; this can be used to incorporate MSn data. Final
    molecules are written to the specified file and/or returned in smiles format. This function represents the central
    building method used by MetaboBlend; :py:meth:`metaboblend.build_structures.generate_structures` provides a simple
    interface for generating structures of a given mass whilst
    :py:meth:`metaboblend.build_structures.annotate_msn` allows for the generation and scoring of structures using
    information from fragmentation spectra.

    :param mf: List of integers detailing the molecular formula of the target metabolite, in the format
        [C, H, N, O, P, S].

    :param exact_mass: The exact mass (float) of the target metabolite.

    :param max_n_substructures: The maximum number of substructures to be used for building molecules.

    :param path_substructure_db: The path to the SQLite 3 substructure database, as generated by
        :py:meth:`metaboblend.databases.SubstructureDb`.

    :param path_connectivity_db: The path to the SQLite 3 connectivity database, as generated by
        :py:meth:`metaboblend.databases.create_isomorphism_database`.

    :param prescribed_mass: A mass by which to filter results; if not provided, all possible structures will be
        generated.

    :param ppm: The maximal tolerated m/z deviation (in parts per million) of the mass of substructures from the
        supplied `fragment_masses`.

    :param ncpus: How many CPUs to utilise; if left as None, :py:meth:`os.cpu_count` is used.

    :param table_name: The table specified within the substructure database will be used to generate
        molecules. Will be removed after structures have been built, unless 'clean = False' is set.

    :param clean: Whether to remove the temporary table of substructures, table_name`, after the method is complete.

    :param isomeric_smiles:  If True, writes smiles with non-structural isomeric information.

    :return: Returns a set of unique SMILEs strings.
    """

    db = SubstructureDb(path_substructure_db, path_connectivity_db)
    tolerance = 0.001

    if prescribed_mass is None:
        exact_mass__1 = round(exact_mass)

    else:  # prescribed substructure build method
        if ((prescribed_mass / 1000000) * ppm) > 0.001:
            fragment_tolerance = round((prescribed_mass / 1000000) * ppm, 4)
        else:
            fragment_tolerance = 0.001

        prescribed_subset = db.select_mass_values("0_0001", [round(prescribed_mass)], table_name)
        prescribed_subset = [m for m in prescribed_subset[0] if abs(m - prescribed_mass) <= fragment_tolerance]

        if len(prescribed_subset) == 0:
            return {}

        loss = exact_mass - prescribed_mass
        exact_mass__1 = round(loss)

        if ((exact_mass / 1000000) * ppm) > 0.001:
            tolerance = round((exact_mass / 1000000) * ppm, 4)

        max_n_substructures -= 1  # we find sets of mols that add up to the loss, not the precursor mass

    if os.name == "nt":  # multiprocessing freeze support on windows
        multiprocessing.freeze_support()

    # select groups of masses at low mass resolution
    integer_mass_values = [m for m in db.select_mass_values("1", [], table_name) if m <= exact_mass__1]
    if len(integer_mass_values) == 0:
        return {}

    integer_subsets = list(subset_sum(integer_mass_values, exact_mass__1, max_n_substructures))

    configs_iso = db.k_configs()

    substructure_subsets = []
    for integer_subset in integer_subsets:
        if len(integer_subset) > max_n_substructures or len(integer_subset) == 0:
            continue

        # refine groups of masses to 4dp mass resolution
        exact_mass_values = db.select_mass_values("0_0001", integer_subset, table_name)

        if prescribed_mass is not None:
            exact_mass_values = [prescribed_subset] + exact_mass_values

        # use combinations to get second group of masses instead of subset sum - subset sum is integer mass only
        exact_subsets = []
        for mass_combo in itertools.product(*exact_mass_values):
            if abs(sum(mass_combo) - exact_mass) <= tolerance:
                exact_subsets.append(mass_combo)

        if len(exact_subsets) == 0:
            continue

        # refines groups based on ecs and gets substructures from db (appends to substructure_subsets)
        for exact_subset in exact_subsets:
            substructure_subsets += build_from_subsets(exact_subset, mf=mf, table_name=table_name, db=db)

    with multiprocessing.Pool(processes=ncpus) as pool:  # send sets of substructures for building
        smi_dicts = pool.map(
            partial(substructure_combination_build, configs_iso=configs_iso,
                    prescribed_structure=prescribed_mass, isomeric_smiles=isomeric_smiles,
                    bond_enthalpies=get_bond_enthalpies()),
            substructure_subsets
        )

    smi_dict = {}
    for d in smi_dicts:
        for k in d.keys():
            try:
                smi_dict[k][1].update(d[k][1])

                if d[k][0] < smi_dict[k][0]:
                    smi_dict[k][0] = d[k][0]

            except KeyError:
                smi_dict[k] = d[k]

    db.close(clean)

    return smi_dict


def gen_subs_table(db, ha_min, ha_max, max_degree, max_atoms_available, max_mass, table_name="subset_substructures",
                   minimum_frequency=None):
    """
    Generate a temporary secondary substructure table restricted by a set of parameters. Generated as an initial step
    in :py:meth:`metaboblend.build_structures.generate_structures` and
    :py:meth:`metaboblend.build_structures.annotate_msn` in order to limit the processing overhead as a result of
    repeatedly querying the SQLite substructure database.

    :param max_mass: The maximum allowed mass of substructures in the temporary table; there is no point considering
        substructures with greater mass than the target mol.

    :param db: Connection to a :py:meth:`metaboblend.databases.SubstructureDb` from which to extract substructures.

    :param ha_min: Minimum value of `heavy_atoms` for substructures to be transferred into the temporary table.
        If None, no limit is applied.

    :param ha_max: Maximum value of `heavy_atoms` for substructures to be transferred into the temporary table.
        If None, no limit is applied.

    :param max_degree: The maximum total valence (ie, the product of `atoms_available` and the degree of their bonds)
        to be included in the temporary table.

    :param max_atoms_available: The maximal atoms available of substructures to be included in the temporary table.

    :param table_name: Defaults to "subset_substructures", which is cleaned up upon database closure. The name of the
        table to be generated

    :param minimum_frequency: The minimum frequency of substructures in table_name; e.g. substructures have a frequency
        of 1 if they are unique.

    :return: The name of the temporary secondary substructure table.
    """

    db.cursor.execute("DROP TABLE IF EXISTS %s" % table_name)

    if minimum_frequency is None:
        freq_statement = ""
    else:
        freq_statement = """
                            AND smiles IN 
                                (SELECT smiles 
                                    FROM hmdbid_substructures 
                                    GROUP BY smiles 
                                    HAVING COUNT(*) >= {})
                         """.format(minimum_frequency,)

    if ha_min is None:
        ha_min_statement = ""
    else:
        ha_min_statement = """
                              AND heavy_atoms >= %s""" % str(ha_min)

    if ha_max is None:
        ha_max_statement = ""
    else:
        ha_max_statement = """
                              AND heavy_atoms <= %s""" % str(ha_max)

    db.cursor.execute("""CREATE TABLE {} AS
                             SELECT * FROM substructures WHERE
                                 atoms_available <= {} AND
                                 valence <= {} AND
                                 exact_mass__1 < {}{}{}{}
                      """.format(table_name,
                                 max_atoms_available,
                                 max_degree,
                                 max_mass,
                                 freq_statement,
                                 ha_min_statement,
                                 ha_max_statement))

    db.create_indexes(table=table_name, selection="gen_subs_table")

    return table_name


def build_from_subsets(exact_subset, mf, table_name, db):
    """
    A stage of the :py:meth:`metaboblend.build_structures.build` workflow for generating molecules to a given mass
    from substructures. At this stage, mass subsets have been identified in the substructure database. Each of these
    groups are now filtered further by identifying masses that refer to valid subsets of molecules, before they are
    built to generate new molecules.

    :param db: The substructure and connectivity database. Elemental compositions and substructures are retrieved from
        the database; this information is listed as "substructure_subset" and will be appended to the
        substructure_subsets list provided as a parameter.

    :param exact_subset: Group of masses that sum to the correct total mass, refer to substructures in the substructure
        database.

    :param mf: List of integers detailing the molecular composition of the target metabolite, in the format
        `[C, H, N, O, P, S]`.

    :param table_name: The name of the table within the substructure database from which to extract substructures. A
        prefiltered table based on the parameters specified in :py:meth:`metaboblend.build_structures.build`. See
        :py:meth:`metaboblend.build_structures.gen_subs_table`.
    """

    substructure_subsets = []

    mf_subset = combine_mfs(exact_subset, db, table_name, "0_0001")

    if len(mf_subset) == 0:
        return []

    for ec_product in itertools.product(*mf_subset):

        if mf != list(numpy.array(ec_product).sum(axis=0)):
            continue  # check each set of elemental compositions matches the target mol

        substructure_subset = db.select_substructures(ec_product, table_name)

        if len(substructure_subset) == 0:
            continue

        substructure_subsets.append(substructure_subset)

    return substructure_subsets


def get_bond_enthalpies():

    return {1.0: {'C': {'C':  348, 'N':  305, 'O':  360, 'P':  264, 'S':  272},
                  'N': {'C':  305, 'N':  163, 'O':  222, 'P': None, 'S': None},
                  'O': {'C':  360, 'N':  222, 'O':  146, 'P':  335, 'S': None},
                  'P': {'C':  264, 'N': None, 'O':  335, 'P':  201, 'S': None},
                  'S': {'C':  272, 'N': None, 'O': None, 'P': None, 'S':  226}},
            1.5: {'C': {'C':  837, 'N':  890, 'O': None, 'P': None, 'S': None},
                  'N': {'C':  890, 'N':  944, 'O': None, 'P': None, 'S': None},
                  'O': {'C': None, 'N': None, 'O': None, 'P': None, 'S': None},
                  'P': {'C': None, 'N': None, 'O': None, 'P': None, 'S': None},
                  'S': {'C': None, 'N': None, 'O': None, 'P': None, 'S': None}},
            2.0: {'C': {'C':  612, 'N':  613, 'O':  743, 'P': None, 'S':  573},
                  'N': {'C':  613, 'N':  409, 'O':  607, 'P': None, 'S': None},
                  'O': {'C':  743, 'N':  607, 'O':  496, 'P':  544, 'S':  522},
                  'P': {'C': None, 'N': None, 'O':  544, 'P': None, 'S':  335},
                  'S': {'C':  573, 'N': None, 'O':  522, 'P':  335, 'S':  425}}}


def substructure_combination_build(substructure_subset, configs_iso, prescribed_structure, isomeric_smiles, bond_enthalpies):
    """
    Final stage for building molecules; takes a combination of substructures (substructure_combination) and builds them
    according to graphs in the substructure database. May be run in parallel.

    :param substructure_subset: Combinations of substructures for building mols.

    :param configs_iso: Possible substructure combinations extracted from the connectivity database. A tuple containing
        tuples for each substructure; these tuples specify how many bonds each substructure can make.

    :param prescribed_structure: Prescribed fragment mass for building.

    :param isomeric_smiles: True/False, should output smiles be written with isomeric information?

    :return: List of smiles representing molecules generated (and the substructures used to generate them).
    """

    smis = {}

    for substructure_combination in itertools.product(*substructure_subset):
        substructure_combination[0]["fragment"] = True
        substructure_combination = sorted(substructure_combination, key=itemgetter('atoms_available', 'valence'))

        v_a = ()
        if prescribed_structure is not None:
            fragment_indexes = []
        j = -1
        for i, d in enumerate(substructure_combination):
            v_a += (tuple(d["degree_atoms"].values()),)  # obtain valence configuration of the set of substructures

            for atom_available in tuple(d["degree_atoms"].values()):
                j += 1

                try:
                    if prescribed_structure is not None and d["fragment"]:
                        fragment_indexes.append(j)
                except KeyError:
                    continue

        if str(v_a) not in configs_iso:  # check mols "fit" together according to the connectivity database
            continue

        mol_comb, atoms_available, atoms_to_remove, bond_types, bond_mismatch = reindex_atoms(substructure_combination)

        if bond_mismatch:
            continue  # check that bond types are compatible (imperfect check)

        for edges in configs_iso[str(v_a)]:  # build mols for each graph in connectivity db
            if prescribed_structure is not None:
                non_fragment_edges = False

                for edge in edges:  # check that edges only connect to fragment ion
                    if edge[0] not in fragment_indexes and edge[1] not in fragment_indexes:
                        non_fragment_edges = True

                if non_fragment_edges:
                    continue

            mol_e, total_bde = add_bonds(mol_comb, edges, atoms_available, bond_types, bond_enthalpies)  # add bonds between substructures

            if mol_e is None or total_bde is None:
                continue

            atoms_to_remove.sort(reverse=True)
            [mol_e.RemoveAtom(a) for a in atoms_to_remove]  # clean up dummy atoms

            mol_out = mol_e.GetMol()  # generate the final (non-editable) mol

            try:
                Chem.SanitizeMol(mol_out)  # clean the mol - ensure it is valid & canonical
            except:
                continue

            try:  # append the canonical smiles of the final structure
                final_structure = Chem.MolToSmiles(mol_out, isomericSmiles=isomeric_smiles)
            except RuntimeError:
                continue  # bad bond type violation

            final_substructures = set(subs["smiles"] for subs in substructure_combination)

            try:
                smis[final_structure][1].update(final_substructures)

                if total_bde < smis[final_structure][0]:
                    smis[final_structure][0] = total_bde

            except KeyError:
                smis[final_structure] = [total_bde, final_substructures]

    return smis
