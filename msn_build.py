import os
import sys
import urllib.request
import csv
import tempfile
import datetime
import networkx as nx
from rdkit import Chem
from shutil import rmtree
import pickle
from rdkit.Chem import Descriptors

sys.path.append(os.path.join("..", "..", "..", "metaboblend", "metaboblend"))
from databases import reformat_xml, update_substructure_database, filter_records, parse_xml, SubstructureDb, get_elements, calculate_exact_mass
from build_structures import build, gen_subs_table

sys.path.append(os.path.join("..", "functions"))
from gen_aux import get_uniq_subs, subset_substructures
from msn_aux import add_small_substructures


def test_build(out_dir, mc, exact_mass, mol, hmdb_id, path_subs, path_k_graphs, path_pkls, heavy_atoms, max_valence,
               accuracy, fragment_masses, ppm, hydrogenation_allowance=2, max_atoms_available=2, max_n_substructures=3):
    """
    MS2 build method. Uses MS2 data to rank generated compounds. Development version for checking that the correct
    compounds are generated by the method.

    :param out_dir: The directory in which to save tool results.

    :param mc: Molecular formula of the compound to be generated.

    :param exact_mass: Exact mass of the compound to be generated.

    :param mol: rdkit mol object containing the compound to be generated. Used for checking the correct mol has been
        generated by the tool.

    :param hmdb_id: HMDB ID of the compound to be generated.

    :param path_subs: Path of the substructure database from which to gather fragments from.

    :param path_k_graphs: Connectivity database for building structures.

    :param path_pkls: PKL files generated for the connectivity database.

    :param heavy_atoms: The allowable heavy atoms of generated structures.

    :param max_valence: The maximal valence of generated structures.

    :param accuracy: Accuracy of the method.

    :param fragment_masses: The neutral mass of the fragments of the MS2 dataset.

    :param ppm: Allowable error for generated compounds.

    :param hydrogenation_allowance: Allowable hydrogenation/dehydrogenation events to be considered by the tool
        (rearrangements)

    :param max_atoms_available: Maximum atoms available for substructures.

    :param max_n_substructures: Maximum number of substructures for generating structures.
    """

    mol_smi = Chem.MolToSmiles(mol)
    pre_reccurence = {}
    
    fragment_masses.sort(reverse=True)

    for fragment_mass in fragment_masses:
        smi_out = os.path.join(out_dir, "{}_".format(hmdb_id) + str(round(fragment_mass, 4)) + ".smi")
        open(smi_out, "w").close()

        single_build = datetime.datetime.now()
        for j in range(0 - hydrogenation_allowance, hydrogenation_allowance + 1):
            hydrogenated_fragment_mass = fragment_mass + (j * 1.007825)
            build(mc, exact_mass, smi_out, heavy_atoms, max_valence, accuracy, max_atoms_available, max_n_substructures,
                  path_k_graphs, path_pkls, path_subs, hydrogenated_fragment_mass, ppm, out_mode="a",
                  table_name="msn_subset")
        print("single_build_time = " + str(datetime.datetime.now() - single_build))
        
        get_uniq_subs(smi_out, ignore_substructures=True)
        with open(smi_out, mode="r") as smis:
            for line in smis:
                if len(line) > 0:
                    try:
                        pre_reccurence[line.strip()] += 1
                    except KeyError:
                        pre_reccurence[line.strip()] = 1

    with open(os.path.join(out_dir, "structure_ranks.csv"), "w", newline="") as ranks_out:
        ranks_csv = csv.writer(ranks_out)
        ranks_csv.writerow(["kekule_smiles", "occurence"])

        num_recurrence = {}
        num_struct = 0
        for smi in pre_reccurence.keys():
            ranks_csv.writerow([smi, pre_reccurence[smi]])
            num_struct += 1
            try:
                num_recurrence[pre_reccurence[smi]] += 1

            except KeyError:
                num_recurrence[pre_reccurence[smi]] = 1
    try:
        recurrence = str(pre_reccurence[mol_smi])

    except KeyError:
        recurrence = "0"
        better_candidates = 0
        for num in num_recurrence.keys():
            better_candidates += num_recurrence[num]

    else:
        better_candidates = 0
        for num in num_recurrence.keys():
            if num >= pre_reccurence[mol_smi]:
                better_candidates += num_recurrence[num]

    if len(pre_reccurence.values()) > 0:
        max_recurrence = str(max(pre_reccurence.values()))
    else:
        max_recurrence = str(0)

    return [
        str(hmdb_id),
        str(mol_smi),
        str(exact_mass),
        str(len(fragment_masses)),  # number of fragments
        recurrence,  # true structure recurrence
        str(better_candidates),  # number of structures above/equal to candidate
        max_recurrence,  # maximal structure recurrence,
        str(num_struct), # tot structures
        str(fragment_masses),  # fragment neutral masses
        str(heavy_atoms),
        str(max_valence),
        str(accuracy),
        str(ppm)
    ]


def run_test(out_dir, ms_data, test_name, heavy_atoms, max_valence, accuracy, ppm, db_path, test_type="ind_exp",
             subset=True, max_atoms_available=2, minimum_frequency=None):
    """
    Wrapper for running tests for the MS2 structure generation & ranking method.

    :param out_dir: The directory in which to output results of the testing.

    :param ms_data: Dictionary generated by parse_testing_data or similar.

    :param test_name: Name of the test.

    :param heavy_atoms: Allowable heavy atoms of substructures.

    :param max_valence: Maximal valence of sets of substructures.

    :param accuracy: Accuracy of the build method.

    :param ppm: Allowable error of the build method.

    :param db_path: Path of the substructure database.

    :param test_type: The type of test to be run.

    :param subset: Whether or not to only include substructures generated by the compound of interest.

    :param max_atoms_available: Maximum atoms available for substructures used for building.
    """

    with open(os.path.join(out_dir, "results.csv"), newline="", mode="w") as overall_results:
        results_csv = csv.writer(overall_results)
        if test_type == "ind_exh_exp":
            results_csv.writerow([
                "category",
                "HMDB_ID",
                "SMILES",
                "Precursor_Mass",
                "Reconstructed",
                "Total_Structures",
                "Unique_Structures",
                "Heavy_Atoms",
                "Max_Valence",
                "Accuracy"
            ])
        else:
            results_csv.writerow([
                "category",
                "HMDB_ID",
                "SMILES",
                "Precursor_Mass",
                "Num_Peaks",
                "True_Recurrence",
                "Structure_Ranking",
                "Maximal_Recurrence",
                "Total_Structures",
                "Fragment_Masses",
                "Heavy_Atoms",
                "Max_Valence",
                "Accuracy",
                "ppm"
            ])

    if subset:
        pass
    else:
        if test_type == "ind_exp":
            C(out_dir, ms_data, heavy_atoms, max_valence, accuracy, ppm, db_path,
              max_atoms_available=max_atoms_available, minimum_frequency=minimum_frequency)
        elif test_type == "ind_exh_exp":
            D(out_dir, ms_data, heavy_atoms, max_valence, accuracy, db_path,
              max_atoms_available=max_atoms_available, minimum_frequency=minimum_frequency)


def C(out_dir, ms_data, heavy_atoms, max_valence, accuracy, ppm, db_path, max_atoms_available=2,
      minimum_frequency=None):
    """Run a test on MS2 data. See run_test."""
    
    db = SubstructureDb(db_path, "")
    gen_subs_table(db, heavy_atoms, max_valence, max_atoms_available,
                   300, table_name="msn_subset",
                   minimum_frequency=minimum_frequency)
    add_small_substructures(db_path, "msn_subset")
    db.close()

    for category in ms_data.keys():
        os.mkdir(os.path.join(out_dir, category))
        for hmdb in ms_data[category].keys():
            if hmdb == "":
                continue

            os.mkdir(os.path.join(out_dir, category, hmdb))

            ms_data[category][hmdb]["neutral_precursor_ion_mass"] \
                = ms_data[category][hmdb]["precursor_ion_mass"] - 1.007276
            ms_data[category][hmdb]["neutral_peaks"] = [peak - 1.007276 for peak in ms_data[category][hmdb]["peaks"]]
            
            print(hmdb)
            test_build_start = datetime.datetime.now()
            with open(os.path.join(out_dir, "results.csv"), newline="", mode="a") as overall_results:
                rcsv = csv.writer(overall_results)

                rcsv.writerow([category] + test_build(
                    out_dir=os.path.join(out_dir, category, hmdb),
                    mc=ms_data[category][hmdb]["mc"],
                    exact_mass=ms_data[category][hmdb]["neutral_precursor_ion_mass"],
                    mol=ms_data[category][hmdb]["mol"],
                    hmdb_id=hmdb,
                    path_subs=db_path,
                    path_k_graphs="../../Data/databases/k_graphs.sqlite",
                    path_pkls="../../Data/databases/pkls",
                    heavy_atoms=heavy_atoms, max_valence=max_valence, accuracy=accuracy,
                    fragment_masses=ms_data[category][hmdb]["neutral_peaks"],
                    ppm=ppm,
                    max_atoms_available=max_atoms_available
                ))
            print("test_build_time = " + str(datetime.datetime.now() - test_build_start))


def D(out_dir, ms_data, heavy_atoms, max_valence, accuracy, db_path, max_atoms_available=2, minimum_frequency=None):
    """Run a test on the standard build method. See run_test."""
    
    db = SubstructureDb(db_path, "")
    gen_subs_table(db, heavy_atoms, max_valence, max_atoms_available,
                   300, table_name="D_subset", minimum_frequency=minimum_frequency)
    db.close()

    for category in ms_data.keys():
        for hmdb in ms_data[category].keys():
            ms_data[category][hmdb]["neutral_precursor_ion_mass"] \
                = ms_data[category][hmdb]["precursor_ion_mass"] - 1.007276

            build(ms_data[category][hmdb]["mc"], ms_data[category][hmdb]["exact_mass"],
                  "temp_structures.smi", heavy_atoms, max_valence, accuracy, max_atoms_available, 3,
                  path_db=db_path, path_db_k_graphs="../../Data/databases/k_graphs.sqlite",
                  path_pkls="../../Data/databases/pkls", out_mode="w", table_name="D_subset")

            i = -1
            with open("temp_structures.smi", "r") as smi:
                for i, l in enumerate(smi):
                    pass

            total_structures = i + 1

            i = -1
            reconstructed = False
            mol_smi = Chem.MolToSmiles(ms_data[category][hmdb]["mol"])
            get_uniq_subs("temp_structures.smi", ignore_substructures=True)
            with open("temp_structures.smi", "r") as smi:
                for i, line in enumerate(smi):
                    if line.strip() == mol_smi:
                        reconstructed = True

            uniq_structures = i + 1
            
            with open(os.path.join(out_dir, "results.csv"), newline="", mode="a") as overall_results:
                rcsv = csv.writer(overall_results)
                
                rcsv.writerow([
                    str(category),
                    str(hmdb),
                    str(mol_smi),
                    str(str(ms_data[category][hmdb]["neutral_precursor_ion_mass"])),
                    str(reconstructed),
                    str(total_structures),
                    str(uniq_structures),
                    str(heavy_atoms),
                    str(max_valence),
                    str(accuracy)
                ])
