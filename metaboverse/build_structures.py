#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright Â© 2019-2020 Ralf Weber
#
# This file is part of MetaboVerse.
#
# MetaboVerse is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MetaboVerse is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MetaboVerse.  If not, see <https://www.gnu.org/licenses/>.
#

import copy
import itertools
import networkx as nx
import numpy
from operator import itemgetter
from rdkit import Chem


def subset_sum(l, mass, toll=0.001):
    """
    Recursive subset sum algorithm for identifying sets of substructures that make up a given mass; the first step
    of building molecules from substructures.

    :param l: A list of masses from which to identify subsets.

    :param mass: The target mass of the sum of the substructures.

    :param toll: The allowable deviation of the sum of subsets from the target mass.

    :return: A list of lists containing the masses of valid subsets.
    """

    if mass < -toll:
        return

    elif len(l) == 0:
        if -toll <= mass <= toll:
            yield []
        return

    elif abs(sum(l) - mass) <= toll:
        yield l
        return

    for subset in subset_sum(l[1:], mass):
        yield subset
    for subset in subset_sum(l[1:], mass - l[0]):
        yield [l[0]] + subset


def combine_ecs(ss2_grp, db, table_name, accuracy, ppm=None):
    """
    A wrapper for :py:meth:`metaboverse.databases.select_ecs` that instead takes a group of subsets, as generated by
    the second stage of :py:meth:`metaboverse.build_structres.subset_sum` in
    :py:meth:`metaboverse.build_structres.build`.

    :param ss2_grp: A list containing the masses of substructures identified by subset_sum.

    :param db: The :py:meth:`metaboverse.databases.SubstructureDb` in which to search for elemental compositions.

    :param table_name: The name of the table containing substructures in which to search for elemental compositions.

    :param accuracy: To which decimal places of accuracy results are to be limited to.

            * **1** Integer level
            * **0_1** One decimal place
            * **0_01** Two decimal places
            * **0_001** Three decimal places
            * **0_0001** Four decimal places

    :param ppm: The allowable error of the query (in parts per million). If unspecified, only exact matches are
        considered.

    :return: If there are no elemental compositions for any of the masses in the group, then an empty list is returned.
    """

    ecs = []

    for i in range(len(ss2_grp)):
        atoms = db.select_ecs(ss2_grp[i], table_name, accuracy, ppm=ppm)

        if len(atoms) == 0:
            return []

        ecs.append(atoms)

    return ecs


def reindex_atoms(records):
    """
    Parses the libs of groups of substructures that are to be combined; the lib is a dictionary containing details 
    about the substructure, as generated by :py:meth:`metaboverse.databases.get_substructure`. Combines the
    molecules into a single :py:meth:`rdkit.Chem.Mol` object and obtains details on their bonding properties.

    :param records: Takes a list of lib dictionaries that contain details on each substructure to be combined.

    :return: Returns a tuple containing a :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule, followed by information on the substructure bonding properties, including:

        * **atoms_available** A list of the indices of atoms that are available for bonding.

        * **atoms_to_remove*** A list of the indices of dummy atoms that are to be removed in order to bond with other
            substructures.

        * **bond_types** A dictionary containing the indices of atoms that are available for bonding as keys and values
            detailing their bond types. See :py:meth:`metaboverse.build_structures.add_bonds`.
    """

    atoms_available, atoms_to_remove, bond_types = [], [], {}
    mol_comb = Chem.Mol()
    index_atoms = []
    c = 0

    for record in records:
        idxs = []
        for atom in record["mol"].GetAtoms():

            newIdx = atom.GetIdx() + c
            idxs.append(newIdx)

            if atom.GetIdx() in record["degree_atoms"]:
                atoms_available.append(newIdx)
            if atom.GetIdx() in record["dummies"]:
                atoms_to_remove.append(newIdx)
            if atom.GetIdx() in record["bond_types"]:
                bond_types[newIdx] = record["bond_types"][atom.GetIdx()]

        mol_comb = Chem.CombineMols(mol_comb, record["mol"])
        index_atoms.append(idxs)
        c = idxs[-1] + 1

    return mol_comb, atoms_available, atoms_to_remove, bond_types


def add_bonds(mols, edges, atoms_available, bond_types, debug=False):
    """
    Takes a set of substructures and attempts to combine them together to generate a final structure. One of the last
    steps in the :py:meth:`metaboverse.build_structures.build` workflow.

    :param mols: A :py:meth:`rdkit.Chem.CombineMols` object, that stores all the substructures
        as a single molecule.

    :param edges: The edges to use in order to join the substructures together, obtained from the connectivity database
        (:py:meth:`metaboverse.databases.create_isomorphism_database`).

    :param atoms_available: A list of the indices of atoms that are available for bonding.

    :param bond_types:  The type of bonds to be formed by dummy atoms - see :py:meth:`Chem.rdchem.BondType`. Is a
        dictionary whose keys are atom indices and values are bond types, as follows:

            * **1.0** Single

            * **1.5** Aromatic

            * **2.0** Double

    :param debug: Debug print statements provide further information on how the function is generating the connectivity
        database.

        * **True** Print debug statements.

        * **False** Hide debug print statements.

    :return: If unsuccessful, returns None, else returns an :py:meth:`rdkit.Chem.EditableMol` object containing
        the substructures combined into a final single molecule.
    """

    rdkit_bond_types = {1: Chem.rdchem.BondType.SINGLE,
                        1.5: Chem.rdchem.BondType.AROMATIC,
                        2: Chem.rdchem.BondType.DOUBLE}

    G = nx.Graph()
    G.add_edges_from(edges)

    if debug:
        print("## Edges from isomorphism:", edges)
        print("## Matching:", sorted(G.nodes()), atoms_available)

    G = nx.relabel_nodes(G, dict(zip(sorted(G.nodes()), atoms_available)))

    mol_edit = Chem.EditableMol(mols)
    for edge in G.edges():

        if edge[0] in bond_types:
            bt_start = copy.copy(bond_types[edge[0]])
        else:
            if debug:
                print("## Nested dummy with index: {} ".format(edge[0]))
                print("")
            return None

        if edge[1] in bond_types:
            bt_end = copy.copy(bond_types[edge[1]])
        else:
            if debug:
                print("## Nested dummy with index: {} ".format(edge[1]))
                print("")
            return None

        bondMatches = list(set(bt_start).intersection(bt_end))

        if len(bondMatches) == 0:
            if debug:
                print("## bondMatches empty")
                print("")
            return None

        else:
            bt_start.remove(bondMatches[0])
            bt_end.remove(bondMatches[0])

        try:
            mol_edit.AddBond(edge[0], edge[1], rdkit_bond_types[bondMatches[0]])
        except KeyError:
            if debug:
                print("Unknown bond type")
            return None

    return mol_edit


def build(mc, exact_mass, db, fn_out, heavy_atoms, max_valence, accuracy, max_atoms_available, max_n_substructures,
          fragment_mass=None, ppm=None, debug=False, out_mode="w"):
    """
    """

    table_name = gen_subs_table(db, heavy_atoms, max_valence, max_atoms_available)

    if fragment_mass is None:  # standard build method
        exact_mass__1 = round(exact_mass)
        exact_mass__0_0001 = round(exact_mass, 4)

        tolerance = 0.001
    else:  # prescribed substructure build method
        loss = exact_mass - fragment_mass
        exact_mass__1 = round(loss)
        exact_mass__0_0001 = round(loss, 4)

        tolerance = (loss / 1000000) * ppm
        if tolerance < 0.001:
            tolerance = 0.001
        else:
            tolerance = round(tolerance, 4)

        max_n_substructures -= 1

    mass_values = db.select_mass_values(str(accuracy), [], table_name)

    subsets = list(subset_sum(mass_values, exact_mass__1))

    configs_iso = db.k_configs()
    out = open(fn_out, out_mode)

    if debug:
        print("First round (mass: {}) - Values: {} - Correct Sums: {}".format(exact_mass__1, len(mass_values),
                                                                              len(subsets)))
        print("------------------------------------------------------")
    for ss_grp in subsets:
        if len(ss_grp) > max_n_substructures:
            continue

        mass_values_r2 = db.select_mass_values("0_0001", ss_grp, table_name)
        subsets_r2 = list(subset_sum(mass_values_r2, exact_mass__0_0001, tolerance))

        if fragment_mass is not None:
            for i, subset in enumerate(subsets_r2):
                subsets_r2[i] = [round(exact_mass - loss, 4)] + subset

        if debug:
            print("Second round (mass: {}) - Values: {} - Correct Sums: {}".format(exact_mass__0_0001,
                                                                                   len(mass_values_r2),
                                                                                   len(subsets_r2)))
            print("------------------------------------------------------")

        build_from_subsets(configs_iso, subsets_r2, mc, db, out, table_name, ppm, debug)

    out.close()


def gen_subs_table(db, heavy_atoms, max_valence, max_atoms_available):
    """
    Generate a temporary secondary substructure table restricted by a set of parameters. Generated as an initial step
    in :py:meth:`metaboverse.build_structures.build` in order to limit the processing overhead as a result of
    repeatedly querying the SQLite substructure database.

    :param db: Connection to a :py:meth:`metaboverse.databases.SubstructureDb` from which to extract substructures.

    :param heavy_atoms: List of integers used to limit which substructures are transferred into the temporary table.

    :param max_valence: The maximum total valence (ie, the product of `atoms_available` and the degree of their bonds)
        to be included in the temporary table.

    :param max_atoms_available: The maximal atoms available of substructures to be included in the temporary table.

    :return: The name of the temporary secondary substructure table.
    """

    table_name = "subset_substructures"

    db.cursor.execute("DROP TABLE IF EXISTS %s" % table_name)

    db.cursor.execute("""CREATE TABLE {} AS
                             SELECT * FROM substructures WHERE
                                 heavy_atoms IN ({}) AND
                                 atoms_available <= {} AND
                                 valence <= {}
                      """.format(table_name,
                                 ",".join(map(str, heavy_atoms)),
                                 max_valence,
                                 max_atoms_available,))

    return table_name


def build_from_subsets(configs_iso, subsets_r2, mc, db, out, table_name, ppm=None, debug=False):
    """
    """

    for ss2_grp in subsets_r2:
        list_ecs = combine_ecs(ss2_grp, db, table_name, "0_0001", ppm)

        if len(list_ecs) == 0:
            continue

        iii = 0
        for l in itertools.product(*list_ecs):

            sum_ec = list(numpy.array(l).sum(axis=0))
            iii += 1

            if mc != sum_ec and debug:
                print("No match for elemental composition: {}".format(str(sum_ec)))

            elif mc == sum_ec:

                if debug:
                    print("Match elemental composition: {}".format(str(sum_ec)))

                ll = db.select_sub_structures(l, table_name)

                if len(ll) == 0:
                    if debug:
                        print("## No substructures found")
                    continue

                elif len(ll) == 1:
                    if debug:
                        print("## Single substructure")

                else:
                    if debug:
                        print("## {} {} substructures found".format(sum([len(subs) for subs in ll]),
                                                                    str([len(subs) for subs in ll])))

                if debug:
                    print("## {} substructure combinations".format(len(list(itertools.product(*ll)))))

                for lll in itertools.product(*ll):

                    if debug:
                        for record in lll:
                            print(record)
                        print("---------------")

                    lll = sorted(lll, key=itemgetter('atoms_available', 'valence'))

                    nA, v, vA = (), (), ()
                    for d in lll:
                        nA = nA + (d["atoms_available"],)
                        v = v + (d["valence"],)
                        vA = vA + (tuple(d["degree_atoms"].values()),)

                    if str(vA) not in configs_iso:
                        if debug:
                            print("NO:", (str(nA), str(v), str(vA)))
                            print("============")
                        continue
                    else:
                        if debug:
                            print("YES:", (str(nA), str(v), str(vA)))
                            print("============")

                    mol_comb, atoms_available, atoms_to_remove, bond_types = reindex_atoms(lll)
                    if debug:
                        print("## Mols (in memory):", mol_comb)
                        print("## Atoms Available (indexes):", atoms_available)
                        print("## Atoms to remove (dummies):", atoms_to_remove)
                        print("## Type of bonds to form:", bond_types)
                    iso_n = 0
                    for edges in db.isomorphism_graphs(configs_iso[str(vA)]):  # EDGES

                        iso_n += 1
                        if debug:
                            print("## ISO {}".format(iso_n))

                        if debug:
                            print(edges)
                            print("1: Add bonds")
                        mol_e = add_bonds(mol_comb, edges, atoms_available, bond_types)
                        if mol_e is None:
                            continue
                        if debug:
                            print("2: Add bonds")

                        atoms_to_remove.sort(reverse=True)
                        [mol_e.RemoveAtom(a) for a in atoms_to_remove]

                        molOut = mol_e.GetMol()
                        try:
                            Chem.SanitizeMol(molOut)
                        except:
                            if debug:
                                print("Can't sanitize mol ISO: {}".format(iso_n))
                            continue

                        try:
                            out.write("{}\t{}\n".format(Chem.MolToSmiles(molOut),
                                                        str([item["smiles"] for item in lll])))
                        except RuntimeError:
                            if debug:
                                print("Bad bond type violation")
                        if debug:
                            print("## smi (result): {}".format(Chem.MolToSmiles(molOut)))
